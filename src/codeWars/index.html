<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<script>
    // Кто помнит свое время на школьном дворе, когда девочки брали цветок и рвали его лепестки, произнося каждую из следующих фраз каждый раз, когда отрывался лепесток:
    //
    //     "Я тебя люблю"
    // "немного"
    // "много"
    // "страстно"
    // "безумно"
    // "нисколько"
    // Если лепестков больше 6, вы начинаете сначала "I love you"для 7 лепестков, "a little"для 8 лепестков и так далее.
    //
    //     Когда был сорван последний лепесток, раздались крики волнения, мечты, нахлынувшие мысли и эмоции.
    //
    //     Ваша цель в этой ката - определить, какую фразу девушки сказали бы на последнем лепестке цветка с заданным количеством лепестков. Количество лепестков всегда больше 0.

    // function howMuchILoveYou(nbPetals) {
    //        if(nbPetals%6 === 1){
    //            return "I love you"
    //        } if(nbPetals%6 === 2){
    //            return "a little"
    //        } if(nbPetals%6 === 3){
    //            return "a lot"
    //        } if(nbPetals%6 === 4){
    //            return "passionately"
    //        } if(nbPetals%6 === 5){
    //            return "madly"
    //        }if(nbPetals%6 === 6){
    //            return "not at all"
    //        }
    // }
    //
    //             console.log(howMuchILoveYou(1))
    //             console.log(howMuchILoveYou(7))
    //             console.log(howMuchILoveYou(8))
    //             console.log(howMuchILoveYou(9))
    //             console.log(howMuchILoveYou(10))
    //             console.log(howMuchILoveYou(13))
    //             console.log(howMuchILoveYou(14))

    //=============================================================

    // Задача
    // Даны три целых числа a ,b,c, вернуть наибольшее число , полученное после вставки следующих операторов и скобок :+,*,()
    // Другими словами, попробуйте каждую комбинацию a,b,c с [*+()] и верните максимальное полученное значение (подробнее об этом читайте в примечаниях)
    // Пример
    // С числами 1, 2 и 3 вот несколько способов размещения знаков и скобок :
    //
    //     1 * (2 + 3) = 5
    // 1 * 2 * 3 = 6
    // 1 + 2 * 3 = 7
    // (1 + 2) * 3 = 9
    // Таким образом , максимальное значение , которое вы можете получить, равно 9 .

    // function expressionMatter(a, b, c) {
    //    let x = a*(b+c)
    //    let y = a*b*c
    //    let z = a+b*c
    //    let r = (a +b)*c
    //    let e = a +b+c
    //     return Math.max(x,y,z,r,e)
    // }
    //
    // console.log(expressionMatter(2, 1, 2))
    // console.log(expressionMatter(2, 10, 3))
    // console.log(expressionMatter(1, 8, 1))
    //=====================================================================

    //=================================================================================================

    // Задача
    // Учитывая массив целых чисел , Найдите минимальную сумму , которая получается в результате суммирования каждого произведения двух целых чисел .
    //
    //     Примечания
    // Массив/список будет содержать только положительные значения .
    //     Массив/список всегда будет иметь четный размер
    // Ввод >> Примеры вывода
    // minSum({5,4,2,3}) ==> return (22)
    // Объяснение :
    //     Минимальная сумма , полученная при суммировании каждого произведения двух целых чисел ,  5*2 + 3*4 = 22
    // minSum({12,6,10,26,3,24}) ==> return (342)
    // Объяснение :
    //     Минимальная сумма , полученная при суммировании каждого произведения двух целых чисел ,  26*3 + 24*6 + 12*10 = 342
    // minSum({9,2,8,7,5,4,0,6}) ==> return (74)
    // Объяснение :
    //     Минимальная сумма , полученная при суммировании каждого произведения двух целых чисел ,  9*0 + 8*2 +7*4 +6*5 = 74

    // function minSum(arr) {
    //    let x = arr.sort((a,b)=>b-a).slice(0,arr.length/2)
    //    let y = arr.sort((a,b)=>a-b).slice(0,arr.length/2)
    //         let res =0
    //     for (let i = 0; i < x.length; i++){
    //         res += x[i]* y[i]
    //     }
    //     return res
    // }
    //
    // console.log(minSum([5,4,2,3]))
    // console.log(minSum([12,6,10,26,3,24]))
    // console.log(minSum([9,2,8,7,5,4,0,6]))/

    //=====================================================================================================

    // Введение и разминка (настоятельно рекомендуется)
    // Игра со списками/массивами
    // Задача
    // Учитывая массив /список [] целых чисел , Найдите произведение k максимальных чисел.
    //
    //     Примечания
    // Размер массива/списка не менее 3 .
    //
    //     Числа массива/списка будут представлять собой смесь положительных, отрицательных и нулевых значений .
    //
    //     Возможно повторение чисел в массиве/списке .
    //
    //     Ввод >> Примеры вывода
    // maxProduct ({4, 3, 5}, 2) ==>  return (20)
    // Объяснение :
    //     Так как размер (k) равен 2 , то подпоследовательность размера 2 , которая дает произведение максимумов , равна5 * 4 = 20.
    // maxProduct ({8, 10 , 9, 7}, 3) ==>  return (720)
    // Объяснение :
    //     Поскольку размер (k) равен 3 , то подпоследовательность размера 3 , которая дает произведение максимумов , равна 8 * 9 * 10 = 720.
    // maxProduct ({10, 8, 3, 2, 1, 4, 10}, 5) ==> return (9600)
    // Объяснение :
    //     Поскольку размер (k) равен 5 , то подпоследовательность размера 5 , произведение максимумов которой дает . 10 * 10 * 8 * 4 * 3 = 9600
    // maxProduct ({-4, -27, -15, -6, -1}, 2) ==> return (4)
    // Объяснение :
    //     Так как размер (k) равен 2 , то подпоследовательность размера 2 , которая дает произведение максимумов , равна -4 * -1 = 4.
    // maxProduct ({10, 3, -1, -27} , 3)  return (-30)
    // Объяснение :
    //     Поскольку размер (k) равен 3 , то подпоследовательность размера 3 , которая дает произведение максимумов , равна10 * 3 * -1 = -30.

    // function maxProduct(numbers, size){
    //     let sort = numbers.sort((a,b)=> b-a )
    //     return sort.slice(0,size).reduce((a,b)=>a*b)
    // }
    //
    //
    //
    // console.log(maxProduct([4,3,5], 2))
    // console.log(maxProduct([10,8,7,9], 3))

    //=============================================================================================

    // Напишите функцию, которая принимает список строк в качестве аргумента и возвращает отфильтрованный список, содержащий те же элементы, но с удаленными «гусями».
    //
    // Гуси — это любые строки в следующем массиве, который предварительно заполнен в вашем решении:
    //
    //     ["African", "Roman Tufted", "Toulouse", "Pilgrim", "Steinbacher"]
    // Например, если этот массив был передан в качестве аргумента:
    //
    //     ["Mallard", "Hook Bill", "African", "Crested", "Pilgrim", "Toulouse", "Blue Swedish"]
    // Ваша функция вернет следующий массив:
    //
    //     ["Mallard", "Hook Bill", "Crested", "Blue Swedish"]
    // Элементы в возвращаемом массиве должны быть в том же порядке,
    //     что и в исходном массиве, переданном вашей функции, хотя и с удаленными «гусями».
    // Обратите внимание, что все строки будут в том же регистре, что и предоставленные, а некоторые элементы могут повторяться.

    // function gooseFilter (birds) {
    //     var geese = ["African", "Roman Tufted", "Toulouse", "Pilgrim", "Steinbacher"];
    //
    //     return birds.filter((el)=> el !== geese[0] && el !== geese[1] && el !== geese[2] && el !== geese[3] && el !== geese[4])
    //
    // };
    //function gooseFilter (birds) {
    //     var geese = ["African", "Roman Tufted", "Toulouse", "Pilgrim", "Steinbacher"];
    //     return birds.filter(b => !geese.includes(b));
    // };
    // console.log(gooseFilter(["Mallard", "Hook Bill", "African", "Crested", "Pilgrim", "Toulouse", "Blue Swedish"]))

    //===========================================================================================

    // Создайте функцию, которая принимает в качестве аргумента римскую цифру и возвращает ее значение в виде десятичного целого числа. Вам не нужно проверять форму римской цифры.
    //
    //     Современные римские цифры записываются путем выражения каждой десятичной цифры числа, которое нужно закодировать отдельно, начиная с самой левой цифры и пропуская любые 0. Таким образом, 1990 г. отображается как «MCMXC» (1000 = M, 900 = CM, 90 = XC), а 2008 г. отображается как «MMVIII» (2000 = MM, 8 = VIII). Римская цифра 1666 года, "MDCLXVI", использует каждую букву в порядке убывания.
    //
    //     Пример:
    //
    // solution('XXI'); // should return 21
    // Помощь:
    //
    //     Symbol    Value
    // I          1
    // V          5
    // X          10
    // L          50
    // C          100
    // D          500
    // M          1,000
    // Предоставлено rosettacode.org

    // !!!!!!!!!!!!!!function solution (roman) {
    //
    //     let obj ={
    //         I:1,
    //         V:5,
    //         X:10,
    //         L:50,
    //         C:100,
    //         D:500,
    //         M:1000
    //
    //     }
    //
    //     const keys = Object.keys(obj);
    //     let res = 0
    //   for (let i = 0; i<roman.length; i++){
    //       if(roman[i] === 'I'){
    //           res +=1
    //       } else if(roman[i] === 'V'){
    //           res +=5
    //       }else if(roman[i] === 'X'){
    //           res +=10
    //       }else if(roman[i] === 'L'){
    //           res +=50
    //       }else if(roman[i] === 'C'){
    //           res +=100
    //       }else if(roman[i] === 'D'){
    //           res +=500
    //       }else if(roman[i] === 'M'){
    //           res +=1000
    //       }else if (roman.indexOf()[i]===('IV')){
    //           res+4
    //       }
    //   }
    //
    //     return res
    // }
    //
    //
    // console.log(solution('XXX'));
    // console.log(solution('IV'));
    // console.log(solution('I'));
    // console.log(solution('MMVIII'));
    //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    //=========================================================================================

    //
    //     In this little assignment you are given a string of space separated numbers, and have to return the highest and lowest number.
    //
    //         Examples
    //     highAndLow("1 2 3 4 5");  // return "5 1"
    //     highAndLow("1 2 -3 4 5"); // return "5 -3"
    //     highAndLow("1 9 3 4 -5"); // return "9 -5"
    //     Notes
    //     All numbers are valid Int32, no need to validate them.
    //         There will always be at least one number in the input string.
    //         Output string must be two numbers separated by a single space, and highest number is first.

    // function highAndLow(numbers) {
    //     let a = numbers.split(' ').sort((a, b) => b - a)
    //     let res = a[0] + ' ' + a[a.length - 1]
    //
    //     return res
    //
    // }
    //
    //
    // console.log(highAndLow("8 3 -5 42 -1 0 0 -9 4 7 4 -4"))

    //=======================================================================================

    //На каждую хорошую идею ката приходится немало плохих!
    // В этом ката вам нужно проверить предоставленный массив (x) на наличие хороших идей «хорошо» и
    // плохих идей «плохо». Если есть одна или две хорошие идеи, верните «Опубликовать!», если их больше 2,
    //     верните «Чую серию!». Если нет хороших идей, как это часто бывает, верните «Fail!».

    // 1 const well=(x) => x.includes('good') ? 'Publish!' : 'Fail'

    // function well(x) {
    //     let str = []
    //     for (let i = 0; i < x.length; i++) {
    //         if (x[i] === 'good') {
    //             str.push('good')
    //         }
    //     }
    //     if (str.length > 2) {
    //         return 'I smell a series!'
    //     } else if (str.length) {
    //         return 'Publish!'
    //     } else if (!str.length) {
    //         return 'Fail!'
    //     }
    //
    // }


    // 3 function well(x){
    //     let count = 0;
    //     for (let i = 0; i < x.length; i++) {
    //         if (x[i] === 'good') {
    //             count++;
    //             if (count == 3)
    //                 break;
    //         }
    //     }
    //     return ['Fail!', 'Publish!', 'Publish!', 'I smell a series!'][count]
    // }
    //
    //
    // console.log(well(['bad', 'bad', 'bad']));
    // console.log(well(['good', 'bad', 'bad', 'bad', 'good']));
    // console.log(well(['good', 'bad', 'bad', 'bad', 'bad', 'good', 'bad', 'bad', 'good']));
    // console.log(well(['good', 'bad', 'bad', 'good', 'bad', 'good', 'bad', 'bad', 'good']));
    //    // console.log(well(["bad","bad","bad","bad","bad","good","bad","bad","bad","bad","good","bad"]));

    //=============================================================================================

    // В этом простом упражнении вы создадите программу, которая принимает значение ,
    //     integer и возвращает список его кратных до другого значения, limit .
    //     Если limitкратно integer, оно также должно быть включено.
    //     В функцию всегда будут передаваться только положительные целые числа, не состоящие из 0.
    // Предел всегда будет выше основания.
    //
    //     Например, если переданы параметры (2, 6), функция должна возвращать [2, 4, 6]значения 2, 4 и 6, кратные от 2 до 6.

    // function findMultiples(integer, limit) {
    //     let arr = []
    //     for(let i = integer; i<=limit;i+=integer){
    //              arr.push(i)
    //
    //         }
    //     return arr
    // }
    // console.log(findMultiples(5, 25));   //[5, 10, 15, 20, 25]
    // console.log(findMultiples(5, 7));
    //=====================================================================================================

    //==============================================================================================

    // Given a 2D ( nested ) list ( array, vector, .. ) of size m * n, your task is to find the sum of the minimum values in each row.
    //
    //     For Example:
    //
    //     [ [ 1, 2, 3, 4, 5 ]        #  minimum value of row is 1
    //     , [ 5, 6, 7, 8, 9 ]        #  minimum value of row is 5
    //     , [ 20, 21, 34, 56, 100 ]  #  minimum value of row is 20
    // ]
    // So the function should return 26 because the sum of the minimums is 1 + 5 + 20 = 26.
    //
    // Note: You will always be given a non-empty list containing positive values.
    //
    //     ENJOY CODING :)

    // function sumOfMinimums(arr) {
    //    let res = 0
    //     arr.map(el=>{
    //      res += el.sort((a,b)=>a-b).shift()
    //    })
    //     return res
    // }
    //
    // console.log(sumOfMinimums([[7, 9, 8, 6, 2], [6, 3, 5, 4, 3], [5, 8, 7, 4, 5]]));

    //======================================================================================================

    // Ваша задача состоит в том, чтобы создать функцию,
    //     которая может принимать любое неотрицательное
    // целое число в качестве аргумента и возвращать его с цифрами в порядке убывания.
    //     По сути, переставьте цифры, чтобы получить максимально возможное число.
    //
    //     Примеры:
    // Вход: 42145 Выход:54421
    //
    // Вход: 145263 Выход:654321
    //
    // Вход: 123456789 Выход:987654321
    //
    //

    //
    // function descendingOrder(n){
    //
    //     return Number(String(n).split('').sort((a,b)=>b-a).join('') )
    // }
    //
    //
    // console.log(descendingOrder(1021));

    //===================================================================================

    // Вам дадут слово. Ваша задача — вернуть средний символ слова. Если длина слова нечетная,
    //     вернуть средний символ. Если длина слова четная, верните средние 2 символа.
    //
    //     #Примеры:
    //
    // Kata.getMiddle("test") should return "es"
    //
    // Kata.getMiddle("testing") should return "t"
    //
    // Kata.getMiddle("middle") should return "dd"
    //
    // Kata.getMiddle("A") should return "A"
    // #Вход
    //
    // Слово (строка) длины 0 < str < 1000(в javascript вы можете получить чуть больше 1000 в некоторых
    // тестовых примерах из-за ошибки в тестовых примерах). Вам не нужно тестировать для этого. Это только здесь,
    //     чтобы сказать вам, что вам не нужно беспокоиться о тайм-ауте вашего решения.
    //
    //     #Выход
    //
    // Средний символ (символы) слова, представленного в виде строки.
    //

    // function getMiddle(s) {
    //     // let arr = s.split(' ')
    //     if(s.length % 2 === 0){
    //         return s[s.length /2-1] +s[s.length /2]
    //     }else {
    //        return  s[Math.floor(s.length /2)]
    //     }
    //
    // }
    //
    // console.log(getMiddle("test"));
    // console.log(getMiddle("testing"));
    // console.log(getMiddle("middle"));

    //==============================================================================================================

    //     В этом ката вы создадите функцию,
    //         которая берет список неотрицательных целых чисел и строк
    //     и возвращает новый список с отфильтрованными строками.
    //
    //         Пример
    //     filter_list([1,2,'a','b']) == [1,2]
    //     filter_list([1,'a','b',0,15]) == [1,0,15]
    //     filter_list([1,2,'aasf','1','123',123]) == [1,2,123]

    // function filter_list(l) {
    //    return l.filter(el=> el === Number(el))
    // }
    //
    // console.log(filter_list([1, 2, 'a', 'b']));

    //==============================================================================================

    //     Создайте функцию, которая возвращает значение, умноженное на 50 и увеличенное на 6. Если введенное значение
    //     является строкой, оно должно возвращать «Ошибка».


    //     const problem = (x)=> typeof x === 'number' ? x*50+6:'Error'

    //=====================================================================================================

    // Американцы странные люди: в их домах первый этаж фактически является цокольным, а 13-го этажа нет (из-за суеверия).
    //
    // Напишите функцию, которая по заданному нижнему пределу в американской системе возвращает нижний предел в европейской системе.
    //
    //     Когда 1-й этаж заменяется цокольным этажом, а 13-й этаж удаляется, числа перемещаются вниз, чтобы занять свое место. В случае выше 13 они перемещаются вниз на два, потому что под ними есть два пропущенных числа.
    //
    // Подвалы (негативы) остаются такими же, как и универсальный уровень.
    //
    //     Больше информации здесь
    //
    // Примеры
    // 1  =>  0
    // 0  =>  0
    // 5  =>  4
    // 15  =>  13
    // -3  =>  -3


    // function getRealFloor(n) {
    //     if(n < 1){
    //         return n
    //     }else if(n>13){
    //       return   n-2
    //     }else{
    //         n-1
    //     }
    //
    // }

    //======================================================================================================

    // Проверьте, содержит ли строка одинаковое количество «x» и «o».
    // Метод должен возвращать логическое значение и не учитывать регистр.
    //     Строка может содержать любой символ.
    //
    //     Примеры ввода/вывода:
    //
    // XO("ooxx") => true
    // XO("xooxx") => false
    // XO("ooxXm") => true
    // XO("zpzpzpp") => true // when no 'x' and 'o' is present should return true
    // XO("zzoo") => false
    //

    // const XO =(str)=> {
    //   let arr = str.toLowerCase().split('')
    //     let x = []
    //     let y = []
    //     for (let i = 0; i<arr.length; i ++){
    //         if(arr[i]==='x'){
    //             x.push(arr[i])
    //         }else if(arr[i]==='o'){
    //             y.push(arr[i])
    //         }
    //     }
    //     return x.length === y.length
    // }
    //
    //
    //
    // console.log(XO('xo'));
    // console.log(XO("xxOo"));
    // console.log(XO("xxxm"));
    // console.log(XO("Oo"));
    // console.log(XO("ooom"));

    //=================================================================================================================

    // Write a function that returns a string in which firstname is swapped with last name
    // Example(Input --> Output)

    // "john McClane" --> "McClane john"

    // const nameShuffler=(str)=> str.split(' ').reverse().join(' ')
    // console.log(nameShuffler('john McClane'));

    //==========================================================================================================
    // Дан массив чисел. В цикле while обойдите массив и значения всех элементов
    // с нечетным индексом умножьте на 2.
    // Значения элементов с четным индексом должны остаться без изменения.
    //
    //     let arr = [1,2,3,4,5]
    //     let index =0
    //     while (index <arr.length){
    //       if(index%2==1){
    //           arr[index] *=2;
    //       }
    //
    //         index++
    //     }
    // console.log(arr)

    //============================================================================================================


    // Тролли атакуют ваш раздел комментариев!
    //     Обычный способ справиться с этой ситуацией — удалить все гласные из комментариев троллей, нейтрализуя угрозу.
    //     Ваша задача — написать функцию, которая принимает строку и возвращает новую строку, в которой удалены все гласные.
    //     Например, строка «Этот сайт для неудачников, LOL!» станет «Ths wbst s fr lsrs LL!».
    // Примечание: для этой ката yне считается гласной.


    // function disemvowel(str) {
    //     let  arr = ['a','A','o','O','e','E','i','I', 'u','U']
    //
    //     return str.split('').filter(el => el !== arr[0] && el !== arr[1] && el !== arr[2] && el !== arr[3]
    //         && el !== arr[4] && el !== arr[5] && el !== arr[6] && el !== arr[7] && el !== arr[8] && el !== arr[9]
    //     ).join('')
    //
    //
    // }
    // console.log(disemvowel("This website is for losers LOL!"));

    //======================================================================================================

    // Просто, учитывая строку слов, вернуть длину кратчайшего слова (слов).
    //     Строка никогда не будет пустой, и вам не нужно учитывать разные типы данных.

    //  function findShort(s){
    // let arr =  s.split(' ')
    //      let x = []
    //      for(let i =0; i<arr.length;i++){
    //          x.push(arr[i].length)
    //      }
    //      return x.sort((a,b)=>a-b)[0]
    //  }
    //
    //  console.log(findShort("bitcoin take over the world maybe who knows perhaps"));

    //=================================================================================================
    //
    // Выборка чисел из массива по условию
    // Обойдите циклом массив чисел numbers и
    // сохраните в новый массив evenNumbers первые три четных числа из оригинального массива.
    //     Предусмотрите выход из цикла, когда в массиве evenNumbers уже есть три значения.

    // const numbers = [1, 2, 2, 13, 11, 7, 18, 20, 22, 14, 15];
    // const evenNumbers = []
    // for(let i=0; i<numbers.length; i+=2){
    //     evenNumbers.push(numbers[i])
    //     if (evenNumbers.length ===3 ) break
    // }

    //======================================================================================================

    // Банкоматы позволяют использовать 4- или 6-значные PIN-коды,
    //     а PIN-коды не могут содержать ничего, кроме ровно 4 или ровно 6 цифр.
    //     Если функции передана допустимая строка PIN-кода, верните true, иначе верните false.
    //
    // Примеры ( Ввод --> Вывод)
    // "1234"   -->  true
    // "12345"  -->  false
    // "a234"   -->  false

    // function validatePIN(pin) {
    //     const preparedPin = pin.replace(/\D/g, '');
    //
    //     return preparedPin === pin && (pin.length === 4 || pin.length === 6);
    // }
    //     // pin.length === 4 || pin.length ===6 ? true :false
    //
    //
    //
    // console.log(validatePIN("a234"));
    // console.log(validatePIN("-1.234"));
    // console.log(validatePIN("1234567"));
    // console.log(validatePIN("1234"));
    // console.log(validatePIN("123456"));

    //
    // Создайте программу, которая фильтрует список строк и возвращает список, содержащий только имена ваших друзей.
    //
    //     Если в имени ровно 4 буквы, можете быть уверены, что оно должно быть вашим другом! В противном случае, вы можете быть уверены, что он не...
    //
    // Пример: ввод = ["Райан", "Киран", "Джейсон", "Юс"], вывод = ["Райан", "Юс"]
    //
    // то есть
    //
    // friend ["Ryan", "Kieran", "Mark"] `shouldBe` ["Ryan", "Mark"]
    // Примечание: сохраните исходный порядок имен в выводе.

    // function friend(friends){
    //    const arr = []
    //     for(let i =0; i<friends.length;i++){
    //         friends[i].length === 4 && arr.push(friends[i])
    //     }
    //    return arr
    // }
    //
    //
    // console.log(friend(["Ryan", "Kieran", "Mark"]));

    //==============================================================================================

    // Крокетный клуб Western Suburbs имеет две категории членства: Senior и Open. Им нужна ваша помощь с формой заявки, в которой потенциальным членам будет указано, в какую категорию они будут помещены.
    //
    //     Чтобы быть пожилым, член должен быть не моложе 55 лет и иметь гандикап больше 7. В этом крокетном клубе гандикап варьируется от -2 до +26; чем лучше игрок, тем ниже гандикап.
    //
    //     Вход
    // Ввод будет состоять из списка пар. Каждая пара содержит информацию об одном потенциальном члене. Информация состоит из целого числа для возраста человека и целого числа для инвалидности человека.
    //
    //     Выход
    // Вывод будет состоять из списка строковых значений (в Haskell и C: Openили Senior), указывающих, должен ли соответствующий элемент быть помещен в старшую или открытую категорию.
    //
    //     Пример
    // input =  [[18, 20], [45, 2], [61, 12], [37, 6], [21, 21], [78, 9]]
    // output = ["Open", "Open", "Senior", "Open", "Open", "Senior"]

    // function openOrSenior(data){
    //    return data.map(el=> el[0] >= 55 && el[1] > 7 ? 'Senior' : 'Open')
    // }
    //
    // console.log(openOrSenior([[45, 12], [55, 21], [19, -2], [104, 20]]));

    //==========================================================================================

    // const shortestWord = (str) => {
    //        return  str.split(' ').sort((a,b)=>a.length -b.length)[0]
    // }
    //
    //
    // console.log(shortestWord('Lorem ipsum dolor sit amet.')); // sit
    // console.log(shortestWord('consectetur adipisicing elit. rem')); // rem


    // Пожалуйста, напишите функцию, которая суммирует список, но игнорирует любые повторяющиеся элементы в списке.
    //     Например, для списка [3, 4, 3, 6] функция должна вернуть 10.

    // function sumNoDuplicates(numList) {
    //    return numList.filter(function(item, pos) {
    //         return numList.indexOf(item) == pos;
    //     })
    // }
    // console.log(sumNoDuplicates([1, 1, 2, 3]))
    // console.log(sumNoDuplicates([1, 1, 2, 2, 3]))

    //======================================================================================================

    // Завершите функцию, которая принимает строковый параметр и переворачивает
    // каждое слово в строке. Все пробелы в строке должны быть сохранены.
    //
    //     Примеры
    // "This is an example!" ==> "sihT si na !elpmaxe"
    // "double  spaces"      ==> "elbuod  secaps"
    //
    //
    // function reverseWords(str) {
    //
    //     return str.split('').reverse().join('').split(' ').reverse().join(' ')
    // }

    // console.log(reverseWords('double  spaced  words'));

    // const basicOp=(operation, value1, value2)=> {
    // return eval(value1+operation+value2)
    // }
    //
    //
    //
    // console.log(basicOp('+', 4, 786));

    //     const sorting = (a,b) => {
    //      if(a>b)  return 1
    //      if(a<b)  return -1
    //        return 0
    //     }
    //
    //     const food = ["Apple", "Melon", "Banana", "Yogurt", "Orange", "Stawberry"];
    //     food.sort(sorting)
    //     console.log(food)
    //
    //     const players = [
    //         {
    //             id: 1,
    //             name: 'Cristiano',
    //             surname: 'Ronaldo',
    //             club: 'Juventus',
    //         },
    //         {
    //             id: 2,
    //             name: 'Lionel',
    //             surname: 'Messi',
    //             club: 'Barcelona',
    //         },
    //         {
    //             id: 3,
    //             name: 'Karim',
    //             surname: 'Benzema',
    //             club: 'Real Madrid',
    //         },
    //         {
    //             id: 4,
    //             name: 'Maxi',
    //             surname: 'Gomez',
    //             club: 'Valencia',
    //         },
    //         {
    //             id: 5,
    //             name: 'Quincy',
    //             surname: 'Promes',
    //             club: 'Spartak',
    //         },
    //     ];
    // players.sort((a,b)=>sorting(a.surname,b.surname))
    //     console.log(players)


    //=================================================================================================================

    //Практика по деструктуризации объекта
    // Дан объект link. Используя деструктуризацию объекта, создайте
    // новые переменные со значениями 'blank', 'link', 'anchor', 'Click me'.
    // Имена переменных используйте согласно ключам (где необходимо, используйте переименование, создав переменную с именем renamed).

    /*  const link = {
    href: '#',
    title: 'simple link',
    target: 'blank',
    className: 'link',
    id: null,
    children: {
        span: {
            content: 'Click me',
            className: 'anchor',
        },
    },
}

const {
    target,
    className,
    children:{span:{
        content,
        className:renamed
    }}

} = link

console.log(target,className,content,renamed)

*/
    /*
    const players = [

        {
            id: 1,
            name: 'Andres',
            surname: 'Iniesta',
            club: 'Vissel Cobe',
        },
        {
            id: 2,
            name: 'Eden',
            surname: 'Hazard',
            club: 'Real Madrid',
        },
        {
            id: 3,
            name: 'Mo',
            surname: 'Salah',
            club: 'Liverpool',
        },
        {
            id: 4,
            name: 'Lionel',
            surname: 'Messi',
            club: 'Barcelona',
        },
    ];

    const jsonPlayers = JSON.stringify(players)
    console.log(jsonPlayers)
*/

    /*  Первый входной массив — это ключ к правильным ответам на экзамене, например ["а", "а", "б", "г"].
    Второй содержит представленные ответы студент
    Два массива не пусты и имеют одинаковую длину. Возвращает оценку для этого массива ответов,
    давая +4 за каждый правильный ответ, -1 за каждый неправильный ответ и +0 за каждый пустой ответ,
    представленный в виде пустой строки (в C используется символ пробела).
Если оценка < 0, вернуть 0.

Например:

    checkExam(["a", "a", "b", "b"], ["a", "c", "b", "d"]) → 6
checkExam(["a", "a", "c", "b"], ["a", "a", "b",  ""]) → 7
checkExam(["a", "a", "b", "c"], ["a", "a", "b", "c"]) → 16
checkExam(["b", "c", "b", "a"], ["",  "a", "a", "c"]) → 0
*/

    // function checkExam(array1, array2) {
    //    let sum = 0
    //     for(let i = 0; i<array1.length; i++){
    //         if(array1[i]===array2[i]){
    //              sum+=4
    //         } else {
    //             sum +=-1
    //         } if(array2[i]===""){
    //             sum+=1
    //         }
    //     }
    //     return sum < 0 ? 0 : sum
    // }
    //
    // console.log(checkExam(["a", "a", "b", "b"], ["a", "c", "b", "d"])); // 6
    // console.log((checkExam(["a", "a", "c", "b"], ["a", "a", "b", ""])));
    // console.log((checkExam(["a", "a", "b", "c"], ["a", "a", "b", "c"])));


    // Count the number of divisors of a positive integer n.
    //
    //     Random tests go up to n = 500000.
    //
    // Examples (input --> output)
    // 4 --> 3 (1, 2, 4)
    // 5 --> 2 (1, 5)
    // 12 --> 6 (1, 2, 3, 4, 6, 12)
    // 30 --> 8 (1, 2, 3, 5, 6, 10, 15, 30)
    // Note you should only return a number, the count of divisors.
    //     The numbers between parentheses are shown only for you to see which numbers are counted in each case.

    // function getDivisorsCnt(n){
    //    let x = []
    //     for(let i = 0; i<n; i++){
    //        let a = n % i
    //         if(a==0){
    //             x.push(i)
    //         }
    //     }
    //     return x
    // }
    //
    //
    // console.log(getDivisorsCnt(10));

    // Проблема
    // Похоже, какой-то хулиган-сантехник со своим братом снова бегают и портят ваши сцены.
    //
    //     Соединение pipesэтапов вашего уровня вместе должно быть исправлено, прежде чем вы получите больше жалоб.
    //
    //     Список каналов правильный, когда каждый pipeпосле первого индекса больше (+1), чем предыдущий, и нет дубликатов.
    //
    //     Задача
    // Учитывая список a numbers, верните фиксированный список, чтобы значения увеличивались на 1 для каждого индекса от минимального значения до максимального значения (включая оба).
    //
    // Пример
    // Input:  1,3,5,6,7,8 Output: 1,2,3,4,5,6,7,8

    // function pipeFix(numbers){
    //         const arr = []
    //     for(let i = numbers[0]; i<=numbers[numbers.length-1];i++){
    //         arr.push(i)
    //     }
    //     return arr
    // }
    //
    // console.log(pipeFix([6, 9]));
    // console.log(pipeFix([-1, 4]));

    //=========================================================================================================
    //
    //     Task:
    //         Given a list of integers, determine whether the sum of its elements is odd or even.
    //
    //         Give your answer as a string matching "odd" or "even".
    //
    //         If the input array is empty consider it as: [0] (array with a zero).
    //
    //     Examples:
    //         Input: [0]
    //     Output: "even"
    //
    //     Input: [0, 1, 4]
    //     Output: "odd"
    //
    //     Input: [0, -1, -5]
    //     Output: "even"
    //


    // function oddOrEven(array) {
    //     let sum = array.reduce((acc,summ)=> acc+summ,0 )
    //
    //     return Math.abs(sum) %2 ===1   ?  'odd' : 'even'
    // }
    //
    // console.log(oddOrEven([0, 1, 2]));
    // console.log(oddOrEven([1023, -1, 2]));
    //  console.log(oddOrEven([]));
    // console.log(oddOrEven([-1022]));
    // console.log(oddOrEven([-1021]));


    // Напишите функцию, которая принимает массив строк в качестве аргумента и возвращает
    // отсортированный массив, содержащий те же строки,
    // упорядоченные от самой короткой до самой длинной.
    //     Например, если этот массив был передан в качестве аргумента:
    //     ["Telescopes", "Glasses", "Eyes", "Monocles"]
    // Ваша функция вернет следующий массив:
    //     ["Eyes", "Glasses", "Monocles", "Telescopes"]
    // Все строки в массиве, переданном вашей функции, будут иметь разную длину, поэтому вам не придется решать,
    // как упорядочить несколько строк одинаковой длины.

    // function sortByLength (array) {
    //    const arr = array.sort((a,b)=>a.length - b.length)
    //     return arr
    // };
    //
    // console.log(sortByLength(["Beg", "Life", "I", "To"]));

    //==============================================================================================================

    // Вам даны два отсортированных массива, оба из которых содержат только целые числа.
    //     Ваша задача — найти способ объединить их в один, отсортированный по возрастанию.
    //     Завершите функцию mergeArrays(arr1, arr2), где arr1 и arr2 — исходные отсортированные массивы.
    //
    //     Вам не нужно беспокоиться о проверке, так как arr1 и arr2 должны быть массивами с 0 или более целыми числами.
    //     Если и arr1, и arr2 пусты, просто верните пустой массив.
    //
    //     Примечание: arr1 и arr2 могут быть отсортированы в разном порядке.
    //     Также arr1 и arr2 могут иметь одинаковые целые числа. Удалить дубликаты в возвращаемом результате.
    //
    // Примеры (ввод -> вывод)
    // * [1, 2, 3, 4, 5], [6, 7, 8, 9, 10] -> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    //
    // * [1, 3, 5, 7, 9], [10, 8, 6, 4, 2] -> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    //
    // * [1, 3, 5, 7, 9, 11, 12], [1, 2, 3, 4, 5, 10, 12] -> [1, 2, 3, 4, 5, 7, 9, 10, 1

    // function mergeArrays(arr1, arr2) {
    //     let x =arr1.concat(arr2)
    //
    //     return x.filter((el,i)=>x.indexOf(el) == i).sort((a,b)=>a-b)
    // }
    //
    // console.log(mergeArrays([1, 3, 5, 7, 9], [10, 8, 6, 4, 2]));
    // console.log(mergeArrays([1, 3, 5, 7, 9, 11, 12], [1, 2, 3, 4, 5, 10, 12]));


    //     async function getUsers(){
    //         try {
    //             const response = await fetch('https://jsonplaceholder.typicode.com/todos/1')
    //             const data = await response.json()
    //             console.log(data);
    //             throw new Error('WARNOBG')
    //         }catch (error){
    //                 console.error(error.message)
    //         }
    //
    //     }
    //     // getUsers()
    //     // console.log(1)
    //     // console.log(2)
    //     // console.log(3)
    //
    //
    //     async function getUsers1(){
    //         //
    //         // return Promise.resolve([{id:1, title:'asdas', isDone:false}])
    //         return Promise.reject('asdasdasd')
    //
    //     }
    //
    // getUsers1().catch(console.error)

    /*
    Номера в порядке?
        В этом Ката ваша функция получает на вход массив целых чисел.
        Ваша задача — определить, расположены ли числа в порядке возрастания.
        Говорят, что массив находится в порядке возрастания, если нет двух соседних целых чисел,
        где левое целое число превышает по значению правое целое.

        Для целей этого Ката вы можете предположить, что все входные данные допустимы,
        т. е. массивы, содержащие только целые числа.

        Обратите внимание, что массив из 0 или 1 целых чисел автоматически
    считается отсортированным в порядке возрастания, поскольку все (нулевые) соседние пары целых чисел
    удовлетворяют условию, согласно которому левое целое число не превышает правое целое по значению.

        Например:
    //
    // inAscOrder([1,2,4,7,19]); // returns true
    // inAscOrder([1,2,3,4,5]); // returns true
    // inAscOrder([1,6,10,18,2,4,20]); // returns false
    // inAscOrder([9,8,7,6,5,4,3,2,1]); // returns false becau
*/

    // function inAscOrder(arr) {
    //     for(let i = 0;i<arr.length; i++){
    //         if(arr[i]>arr[i+1]){
    //             return false
    //         }
    //     }
    //     return true
    // }
    //
    // console.log(inAscOrder([1, 2, 4, 7, 19]))
    // console.log(inAscOrder([1, 6, 10, 18, 2, 4, 20]))
    // console.log(inAscOrder([9, 8, 7, 6, 5, 4, 3, 2, 1]));
    // console.log(inAscOrder([1, 2, 3, 4, 5]));
    // console.log(inAscOrder([1, 6, 10, 18, 2, 4, 20]));

    //
    // What if we need the length of the words separated by a space to be added at the end of that same word and have it returned as an array?
    //
    //     Example(Input --> Output)
    //
    //     "apple ban" --> ["apple 5", "ban 3"]
    // "you will win" -->["you 3", "will 4", "win 3"]
    // Your task is to write a function that takes a String and returns an Array/list with the length of each word added to each element .
    //
    //     Note: String will have at least one element; words will always be separated by a space.
    //

    // function addLength(str) {
    //         return str.split(' ').map(el=> `${el} ${el.length}`)
    // }
    //
    // console.log(addLength('you will win'));
    // axios.get('https://social-network.samuraijs.com/api/1.0/profile/2')
    //     .then((responce)=>{responce.data}).then((user)=>{console.log(user)})

    // async function getUser(){
    //     const response = await fetch('https://jsonplaceholder.typicode.com/todos/1')
    //     const data = await response.json()
    //     return console.log(data)
    // }
    //
    //    getUser()


    // ================================================================================================

    // Story
    // Ben has a very simple idea to make some profit: he buys something and sells it again. Of course,
    //     this wouldn't give him any profit at all if he was simply to buy and sell it at the same price. '
    // 'Instead, he's going to buy it for the lowest possible price and sell it at the highest.
    //
    //     Task
    // Write a function that returns both the minimum and maximum number of the given list/array.
    //
    // Examples (Input --> Output)
    //     [1,2,3,4,5] --> [1,5]
    //     [2334454,5] --> [5,2334454]
    //     [1]         --> [1,1]
    // Remarks
    // All arrays or lists will always have at least one element,
    //     so you don't need to check the length. Also, your function will always get an array or a list, ' +
    // 'you don't have to check for null, undefined or similar.

    // function minMax(arr){
    //     let arrX = arr.sort((a,b)=>a-b)
    //
    //     return [arrX[0],arrX[arrX.length-1]]
    // }
    //
    // console.log(minMax([1, 2, 3, 4, 5]));
    // console.log(minMax([12133, 2, 3, 4, 5]));
    // console.log(minMax([1]));

    //=======================================================================================================

    // Учитывая список цифр , верните наименьшее число , которое можно составить из этих цифр,
    // используя цифры только один раз (игнорируя дубликаты).
    // Примечания:
    //     В функцию будут переданы только положительные целые числа (> 0), никаких отрицательных значений или нулей.
    //     Ввод >> Примеры вывода
    // minValue ({1, 3, 1})  ==> return (13)

    //
    // function minValue(values){
    //    return Number(values.filter((el,i)=> values.indexOf(el) == i).sort((a,b)=>a-b).join(''))
    // }
    // function minValue(values){
    //     let arr = Array.from(new Set(values))
    //     return parseInt(arr.sort().join(''))
    // }
    // console.log(minValue([4, 7, 5, 7]));

    //==================================================================================================

    // В рамках этой Ката вам нужно создать функцию,
    // которая при наличии триплета возвращает индекс числового элемента,
    // лежащего между двумя другими элементами.
    //     Входными данными для функции будет массив из трех различных чисел (Haskell: кортеж).
    // Например:
    //     gimme([2, 3, 1]) => 0
    // 2 — это число, которое помещается между 1 и 3 , а индекс 2 во входном массиве равен 0 .
    //     Другой пример (просто для ясности):
    // gimme([5, 10, 14]) => 1
    // 10 — это число, которое находится между 5 и 14 , а индекс 10 во входном массиве равен 1 .
    //
    //     МАССИВЫОСНОВЫ


    // function gimme (triplet) {
    //     const copy=[...triplet].sort((a,b)=>a-b)[1]
    //    return triplet.indexOf(copy)
    // }
    //
    // console.log(gimme([2, 3, 1]))
    // console.log(gimme([5, 10, 14]))

    //===================================================================================

    // Рассмотрим массив/список овец, где некоторые овцы могут отсутствовать на своем месте.
    //     Нам нужна функция, которая подсчитывает количество овец, присутствующих в массиве (true означает наличие).
    // Например,
    //
    //     [true,  true,  true,  false,
    //         true,  true,  true,  true ,
    //         true,  false, true,  false,
    //         true,  false, false, true ,
    //         true,  true,  true,  true ,
    //         false, false, true,  true]
    // Правильный ответ будет 17.
    // Подсказка: не забудьте проверить наличие неправильных значений, таких как
    //

    // function countSheeps(arrayOfSheep) {
    //     return arrayOfSheep.filter(el=> el).length
    // }
    //
    // console.log(countSheeps([true,  true,  true,  false,
    //     true,  true,  true,  true ,
    //     true,  false, true,  false,
    //     true,  false, false, true ,
    //     true,  true,  true,  true ,
    //     false, false, true,  true ]))


    //=====================================================================================================


    //     function reverse(string){
    //      const arr = string.split(' ')
    //         let str =``
    //
    //         for(let i=arr.length-1; i>=0; i--){
    //             str +=` ${arr[i]}`
    //         }
    //         return str
    //     }
    //
    // console.log(reverse('I am an expert at this'));

    // ====================================================================================

    // В математике факториал неотрицательного целого числа n, обозначаемый n!,
    //     представляет собой произведение всех положительных целых чисел, меньших или равных n.
    //     Например: 5! = 5 * 4 * 3 * 2 * 1 = 120. По соглашению значение 0! 1.
    //
    // Напишите функцию для вычисления факториала для заданных входных данных.
    //     Если входные данные меньше 0 или больше 12, сгенерируйте исключение типа ArgumentOutOfRangeException(C#),
    // или IllegalArgumentException(Java), или RangeException(PHP), или сгенерируйте RangeError(JavaScript),
    //     или ValueError(Python), или верните -1(C).
    //
    //     Подробнее о факториале можно узнать здесь .
    //

    //
    //     function factorial(n) {
    //         if( n<12 && n>=0){
    //           if(n===0) return 1
    //           return n*factorial(n-1)
    //         }
    //             throw new RangeError("error ");
    //
    // }
    //
    //
    // function factorial(n) {
    //     if ( n>=12 || n<=0) {
    //      throw new RangeError("The argument must be between -500 and 500.");
    //     }
    //
    //     return n>1?n*factorial(n-1):1
    // }
    // console.log(factorial(5))
    // console.log(factorial(1))
    // console.log(factorial(12))
    // console.log(factorial(-1))

    //


    // function multiTable(number) {
    //     let str =''
    //     for(let i = 1;i<=10; i++){
    //         str += `\n${i} * ${number} = ${i*number}`
    //     }
    //
    //     return str
    // }
    //
    //
    // console.log(multiTable(5)); //'1 * 5 = 5\n2 * 5 = 10\n3 * 5 = 15\n4 * 5 = 20\n5 * 5 = 25\n6 * 5 = 30\n7 * 5 = 35\n8 * 5 = 40\n9 * 5 = 45\n10 * 5 = 50'

    // Возможно, вы знаете несколько довольно больших идеальных квадратов. Но как насчет СЛЕДУЮЩЕГО?
    //
    //     Завершите findNextSquareметод, который находит следующий целочисленный идеальный квадрат после квадрата,
    //     переданного в качестве параметра. Напомним, что целочисленный совершенный квадрат — это целое число n, такое что sqrt(n) также является целым числом.
    //     Если параметр сам по себе не является идеальным квадратом, его -1следует вернуть.
    //     Вы можете предположить, что параметр неотрицательный.
    //     Примеры: (Ввод --> Вывод)
    //
    // 121 --> 144
    // 625 --> 676
    // 114 --> -1 since 114 is not a perfect square


    // function findNextSquare(sq) {
    //
    //    const x = Math.sqrt(sq)
    //
    //     return Number.isInteger(Math.sqrt(sq)) ? (Math.sqrt(sq)+1)**2 :-1
    // }
    //
    // console.log(findNextSquare(121));
    // console.log(findNextSquare(625));
    // console.log(findNextSquare(114));

    //=================================================================================================================

    // В маленьком городке население p0 = 1000на начало года. Население регулярно увеличивается на 2 percent1 год, и,
    // кроме того, 50каждый год в город приезжают новые жители. Сколько лет нужно городу, чтобы его население было
    // больше или равно p = 1200количеству жителей?
    //     At the end of the first year there will be:
    //     1000 + 1000 * 0.02 + 50 => 1070 inhabitants
    // At the end of the 2nd year there will be:
    //     1070 + 1070 * 0.02 + 50 => 1141 inhabitants (** number of inhabitants is an integer **)
    // At the end of the 3rd year there will be:
    //     1141 + 1141 * 0.02 + 50 => 1213
    // It will need 3 entire years.
    //     Более общие параметры:
    //     p0, percent, aug (inhabitants coming or leaving each year), p (population to equal or surpass)
    // функция nb_yearдолжна возвращать nколичество полных лет, необходимых для получения населения, большего или равного p.
    //     aug — целое число, процент — положительное или нулевое плавающее число, p0 и p — положительные целые числа (> 0)
    // Examples:
    //     nb_year(1500, 5, 100, 5000) -> 15
    // nb_year(1500000, 2.5, 10000, 2000000) -> 10
    // Примечание:
    //     Не забудьте преобразовать параметр процента в процент в теле вашей функции:
    //     если параметр процента равен 2, вы должны преобразовать его в 0,02.


    //  function nbYear(p0, percent, aug, p) {
    //      const perc = percent / 100
    //
    //      let res
    //      let y = p0
    //      let count = 0
    //
    //      while (y<=p){
    //          res = y + (y * perc) + aug
    //            y = Math.floor(res)
    //          count++
    //      }
    //      return count
    //  }
    //
    //
    //  console.log(nbYear(1000, 2, 50, 1200));
    // console.log(nbYear(1500, 5, 100, 5000));
    // console.log(nbYear(1500000, 2.5, 10000, 2000000));
    //  console.log(nbYear(1500000, 0.25, 1000, 2000000));


    //==============================================================================================================

    // инструкции
    // Напишите функцию, которая принимает одну строку ( word) в качестве аргумента. Функция должна возвращать упорядоченный список, содержащий индексы всех заглавных букв в строке.
    //
    //     Пример
    // Test.assertSimilar( capitals('CodEWaRs'), [0,3,4,6] );

    // var capitals = function (word) {
    //     const arr = word.split('')
    //     const x = []
    //     for(let i = 0; i<arr.length;i++){
    //         if(arr[i] === arr[i].toUpperCase()){
    //             x.push(i)
    //         }
    //     }
    //     return x
    //
    // };
    // console.log(capitals('CodEWaRs'));


    //===================================================================================

    // function sumTwoSmallestNumbers(numbers) {
    //     return numbers.sort((a,b)=> a-b)[0] + numbers[1]
    // }
    //
    // console.log(sumTwoSmallestNumbers([5, 8, 12, 19, 22]));
    // console.log(sumTwoSmallestNumbers([15, 28, 4, 2, 43]));

    // Given two integers a and b, which can be positive or negative, find the sum of all the integers between and including them and return it. If the two numbers are equal return a or b.
    //
    //     Note: a and b are not ordered!
    //
    //     Examples (a, b) --> output (explanation)
    // (1, 0) --> 1 (1 + 0 = 1)
    // (1, 2) --> 3 (1 + 2 = 3)
    // (0, 1) --> 1 (0 + 1 = 1)
    // (1, 1) --> 1 (1 since both are same)
    // (-1, 0) --> -1 (-1 + 0 = -1)
    // (-1, 2) --> 2 (-1 + 0 + 1 + 2 = 2)
    // // Your function should only return a number, not the explanation about how you get that number.
    //         function getSum(a, b) {
    //             let sumA = 0
    //
    //             if(a===b) {
    //                 return a
    //             }
    //             if(a<b){
    //                 for(let i = a; i<=b; i++){
    //                     sumA += i
    //                 }
    //             }
    //             if(a>b){
    //                 for(let i = b; i<=a; i++){
    //                     sumA += i
    //                 }
    //             }
    //
    //             return  sumA
    //         }
    //
    // console.log(getSum(-1, 2))//2
    // console.log(getSum(0, -1))
    // console.log(getSum(5, -1))//5
    // console.log(getSum(543, 546))//2148

    //====================================================================
    //
    // Your team is writing a fancy new text editor and you've been tasked with implementing the line numbering.
    //
    // Write a function which takes a list of strings and returns each line prepended by the correct number.
    //
    //     The numbering starts at 1. The format is n: string. Notice the colon and space in between.
    //
    //     Examples: (Input --> Output)
    //
    //     [] --> []
    //     ["a", "b", "c"] --> ["1: a", "2: b", "3: c"]


    // var number=function(array){
    //     let x = 1
    //     let arr =[]
    //     for(let i = 0; i<array.length; i++){
    //         arr.push(array[i])
    //     }
    //     return array.map((el,i)=> `${i+1}: `+el)
    // }
    // console.log(number(["a", "b", "c"]));
    //

    // function isIsogram(str){
    //     str = str.toLowerCase()
    //   return !str.split('').filter((el,i)=>str.indexOf(el)!== i).length
    //     // return str.indexOf('a')
    // }
    //
    // console.log(isIsogram("Dermatoglyphics"));
    // console.log(isIsogram("isogram"));
    // console.log(isIsogram("Aba"));


    //==================================================================================================


    //     function x(){
    //      let b = 2
    //        return  function f(b, a=b) {
    //         console.log(a, b)
    //     }
    // }
    //     let test = x()
    //     test(undefined,2)
    //     function fn(){
    //         let b =2
    //       return   function test(b, a=b){
    //             console.log(a,let x

    //     }
    //     let test = fn()
    //        test(undefined,3)


    // test(undefined,2)
    // console.log()


    // function findShort(s) {
    //     let x = s.split(' ')
    //     let min = x[0]
    //
    //     for (let i = 0; i < x.length; i++) {
    //         if (x[i].length < min.length) {
    //          min = x[i]
    //         }
    //     }
    //
    //     return min.length
    // }
    //
    // console.log(findShort("bitcoin take over the world maybe who knows perhaps"))


    //====================================================================

    // Write a function that takes a string of parentheses, and determines if the order of the parentheses
    // is valid. The function should return true if the string is valid, and false if it's invalid.
    //
    // Examples
    // "()"              =>  true
    // ")(()))"          =>  false
    // "("               =>  false
    // "(())((()())())"  =>  true
    // Constraints

    // function validParentheses(parenStr) {
    //    const arr = parenStr.split('')
    //     let count = 0
    //     for(let i = 0 ; i<=arr.length; i++){
    //
    //         if(arr[0] ===')') count +=1
    //         if(arr[i] === '('){
    //             count +=1
    //         }
    //         if(arr[i+1] === ')' ) {
    //             count -= 1
    //         }
    //         if(count < 0) {
    //             break
    //         }
    //
    //     }
    //     return  !count
    // }
    //
    // console.log(validParentheses('((()))'))
    // console.log(validParentheses('()()()'))
    // console.log(validParentheses('())(()')) // 1111111111111111
    // console.log(validParentheses('((())'))
    // console.log(validParentheses(')()'))
    // console.log(validParentheses('(())(())()((())))()')) //false
    // console.log(validParentheses(')')) //false


    // =============================================================================================

    function divisors(integer) {

        let arr = []
        let i = 2
        while(i<integer){
            if(integer % i == 0){
                arr.push(i)
            }
            i++
        }
        return !arr.length ? `${integer} is prime` : arr
    }

    console.log(divisors(15)); //[3, 5])
    console.log(divisors(12));
    console.log(divisors(13));
</script>
</body>
</html>
