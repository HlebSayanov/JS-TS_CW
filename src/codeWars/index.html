<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<script>
    // Кто помнит свое время на школьном дворе, когда девочки брали цветок и рвали его лепестки, произнося каждую из следующих фраз каждый раз, когда отрывался лепесток:
    //
    //     "Я тебя люблю"
    // "немного"
    // "много"
    // "страстно"
    // "безумно"
    // "нисколько"
    // Если лепестков больше 6, вы начинаете сначала "I love you"для 7 лепестков, "a little"для 8 лепестков и так далее.
    //
    //     Когда был сорван последний лепесток, раздались крики волнения, мечты, нахлынувшие мысли и эмоции.
    //
    //     Ваша цель в этой ката - определить, какую фразу девушки сказали бы на последнем лепестке цветка с заданным количеством лепестков. Количество лепестков всегда больше 0.

    // function howMuchILoveYou(nbPetals) {
    //        if(nbPetals%6 === 1){
    //            return "I love you"
    //        } if(nbPetals%6 === 2){
    //            return "a little"
    //        } if(nbPetals%6 === 3){
    //            return "a lot"
    //        } if(nbPetals%6 === 4){
    //            return "passionately"
    //        } if(nbPetals%6 === 5){
    //            return "madly"
    //        }if(nbPetals%6 === 6){
    //            return "not at all"
    //        }
    // }
    //
    //             console.log(howMuchILoveYou(1))
    //             console.log(howMuchILoveYou(7))
    //             console.log(howMuchILoveYou(8))
    //             console.log(howMuchILoveYou(9))
    //             console.log(howMuchILoveYou(10))
    //             console.log(howMuchILoveYou(13))
    //             console.log(howMuchILoveYou(14))

    //=============================================================

    // Задача
    // Даны три целых числа a ,b,c, вернуть наибольшее число , полученное после вставки следующих операторов и скобок :+,*,()
    // Другими словами, попробуйте каждую комбинацию a,b,c с [*+()] и верните максимальное полученное значение (подробнее об этом читайте в примечаниях)
    // Пример
    // С числами 1, 2 и 3 вот несколько способов размещения знаков и скобок :
    //
    //     1 * (2 + 3) = 5
    // 1 * 2 * 3 = 6
    // 1 + 2 * 3 = 7
    // (1 + 2) * 3 = 9
    // Таким образом , максимальное значение , которое вы можете получить, равно 9 .

    // function expressionMatter(a, b, c) {
    //    let x = a*(b+c)
    //    let y = a*b*c
    //    let z = a+b*c
    //    let r = (a +b)*c
    //    let e = a +b+c
    //     return Math.max(x,y,z,r,e)
    // }
    //
    // console.log(expressionMatter(2, 1, 2))
    // console.log(expressionMatter(2, 10, 3))
    // console.log(expressionMatter(1, 8, 1))
    //=====================================================================

    //=================================================================================================

    // Задача
    // Учитывая массив целых чисел , Найдите минимальную сумму , которая получается в результате суммирования каждого произведения двух целых чисел .
    //
    //     Примечания
    // Массив/список будет содержать только положительные значения .
    //     Массив/список всегда будет иметь четный размер
    // Ввод >> Примеры вывода
    // minSum({5,4,2,3}) ==> return (22)
    // Объяснение :
    //     Минимальная сумма , полученная при суммировании каждого произведения двух целых чисел ,  5*2 + 3*4 = 22
    // minSum({12,6,10,26,3,24}) ==> return (342)
    // Объяснение :
    //     Минимальная сумма , полученная при суммировании каждого произведения двух целых чисел ,  26*3 + 24*6 + 12*10 = 342
    // minSum({9,2,8,7,5,4,0,6}) ==> return (74)
    // Объяснение :
    //     Минимальная сумма , полученная при суммировании каждого произведения двух целых чисел ,  9*0 + 8*2 +7*4 +6*5 = 74

    // function minSum(arr) {
    //    let x = arr.sort((a,b)=>b-a).slice(0,arr.length/2)
    //    let y = arr.sort((a,b)=>a-b).slice(0,arr.length/2)
    //         let res =0
    //     for (let i = 0; i < x.length; i++){
    //         res += x[i]* y[i]
    //     }
    //     return res
    // }
    //
    // console.log(minSum([5,4,2,3]))
    // console.log(minSum([12,6,10,26,3,24]))
    // console.log(minSum([9,2,8,7,5,4,0,6]))/

    //=====================================================================================================

    // Введение и разминка (настоятельно рекомендуется)
    // Игра со списками/массивами
    // Задача
    // Учитывая массив /список [] целых чисел , Найдите произведение k максимальных чисел.
    //
    //     Примечания
    // Размер массива/списка не менее 3 .
    //
    //     Числа массива/списка будут представлять собой смесь положительных, отрицательных и нулевых значений .
    //
    //     Возможно повторение чисел в массиве/списке .
    //
    //     Ввод >> Примеры вывода
    // maxProduct ({4, 3, 5}, 2) ==>  return (20)
    // Объяснение :
    //     Так как размер (k) равен 2 , то подпоследовательность размера 2 , которая дает произведение максимумов , равна5 * 4 = 20.
    // maxProduct ({8, 10 , 9, 7}, 3) ==>  return (720)
    // Объяснение :
    //     Поскольку размер (k) равен 3 , то подпоследовательность размера 3 , которая дает произведение максимумов , равна 8 * 9 * 10 = 720.
    // maxProduct ({10, 8, 3, 2, 1, 4, 10}, 5) ==> return (9600)
    // Объяснение :
    //     Поскольку размер (k) равен 5 , то подпоследовательность размера 5 , произведение максимумов которой дает . 10 * 10 * 8 * 4 * 3 = 9600
    // maxProduct ({-4, -27, -15, -6, -1}, 2) ==> return (4)
    // Объяснение :
    //     Так как размер (k) равен 2 , то подпоследовательность размера 2 , которая дает произведение максимумов , равна -4 * -1 = 4.
    // maxProduct ({10, 3, -1, -27} , 3)  return (-30)
    // Объяснение :
    //     Поскольку размер (k) равен 3 , то подпоследовательность размера 3 , которая дает произведение максимумов , равна10 * 3 * -1 = -30.

    // function maxProduct(numbers, size){
    //     let sort = numbers.sort((a,b)=> b-a )
    //     return sort.slice(0,size).reduce((a,b)=>a*b)
    // }
    //
    //
    //
    // console.log(maxProduct([4,3,5], 2))
    // console.log(maxProduct([10,8,7,9], 3))

    //=============================================================================================

    // Напишите функцию, которая принимает список строк в качестве аргумента и возвращает отфильтрованный список, содержащий те же элементы, но с удаленными «гусями».
    //
    // Гуси — это любые строки в следующем массиве, который предварительно заполнен в вашем решении:
    //
    //     ["African", "Roman Tufted", "Toulouse", "Pilgrim", "Steinbacher"]
    // Например, если этот массив был передан в качестве аргумента:
    //
    //     ["Mallard", "Hook Bill", "African", "Crested", "Pilgrim", "Toulouse", "Blue Swedish"]
    // Ваша функция вернет следующий массив:
    //
    //     ["Mallard", "Hook Bill", "Crested", "Blue Swedish"]
    // Элементы в возвращаемом массиве должны быть в том же порядке,
    //     что и в исходном массиве, переданном вашей функции, хотя и с удаленными «гусями».
    // Обратите внимание, что все строки будут в том же регистре, что и предоставленные, а некоторые элементы могут повторяться.

    // function gooseFilter (birds) {
    //     var geese = ["African", "Roman Tufted", "Toulouse", "Pilgrim", "Steinbacher"];
    //
    //     return birds.filter((el)=> el !== geese[0] && el !== geese[1] && el !== geese[2] && el !== geese[3] && el !== geese[4])
    //
    // };
    //function gooseFilter (birds) {
    //     var geese = ["African", "Roman Tufted", "Toulouse", "Pilgrim", "Steinbacher"];
    //     return birds.filter(b => !geese.includes(b));
    // };
    // console.log(gooseFilter(["Mallard", "Hook Bill", "African", "Crested", "Pilgrim", "Toulouse", "Blue Swedish"]))

    //===========================================================================================

    // Создайте функцию, которая принимает в качестве аргумента римскую цифру и возвращает ее значение в виде десятичного целого числа. Вам не нужно проверять форму римской цифры.
    //
    //     Современные римские цифры записываются путем выражения каждой десятичной цифры числа, которое нужно закодировать отдельно, начиная с самой левой цифры и пропуская любые 0. Таким образом, 1990 г. отображается как «MCMXC» (1000 = M, 900 = CM, 90 = XC), а 2008 г. отображается как «MMVIII» (2000 = MM, 8 = VIII). Римская цифра 1666 года, "MDCLXVI", использует каждую букву в порядке убывания.
    //
    //     Пример:
    //
    // solution('XXI'); // should return 21
    // Помощь:
    //
    //     Symbol    Value
    // I          1
    // V          5
    // X          10
    // L          50
    // C          100
    // D          500
    // M          1,000
    // Предоставлено rosettacode.org

    // !!!!!!!!!!!!!!function solution (roman) {
    //
    //     let obj ={
    //         I:1,
    //         V:5,
    //         X:10,
    //         L:50,
    //         C:100,
    //         D:500,
    //         M:1000
    //
    //     }
    //
    //     const keys = Object.keys(obj);
    //     let res = 0
    //   for (let i = 0; i<roman.length; i++){
    //       if(roman[i] === 'I'){
    //           res +=1
    //       } else if(roman[i] === 'V'){
    //           res +=5
    //       }else if(roman[i] === 'X'){
    //           res +=10
    //       }else if(roman[i] === 'L'){
    //           res +=50
    //       }else if(roman[i] === 'C'){
    //           res +=100
    //       }else if(roman[i] === 'D'){
    //           res +=500
    //       }else if(roman[i] === 'M'){
    //           res +=1000
    //       }else if (roman.indexOf()[i]===('IV')){
    //           res+4
    //       }
    //   }
    //
    //     return res
    // }
    //
    //
    // console.log(solution('XXX'));
    // console.log(solution('IV'));
    // console.log(solution('I'));
    // console.log(solution('MMVIII'));
    //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    //=========================================================================================

    //
    //     In this little assignment you are given a string of space separated numbers, and have to return the highest and lowest number.
    //
    //         Examples
    //     highAndLow("1 2 3 4 5");  // return "5 1"
    //     highAndLow("1 2 -3 4 5"); // return "5 -3"
    //     highAndLow("1 9 3 4 -5"); // return "9 -5"
    //     Notes
    //     All numbers are valid Int32, no need to validate them.
    //         There will always be at least one number in the input string.
    //         Output string must be two numbers separated by a single space, and highest number is first.

    // function highAndLow(numbers) {
    //     let a = numbers.split(' ').sort((a, b) => b - a)
    //     let res = a[0] + ' ' + a[a.length - 1]
    //
    //     return res
    //
    // }
    //
    //
    // console.log(highAndLow("8 3 -5 42 -1 0 0 -9 4 7 4 -4"))

    //=======================================================================================

    //На каждую хорошую идею ката приходится немало плохих!
    // В этом ката вам нужно проверить предоставленный массив (x) на наличие хороших идей «хорошо» и
    // плохих идей «плохо». Если есть одна или две хорошие идеи, верните «Опубликовать!», если их больше 2,
    //     верните «Чую серию!». Если нет хороших идей, как это часто бывает, верните «Fail!».

    // 1 const well=(x) => x.includes('good') ? 'Publish!' : 'Fail'

        //   2  function well(x){
//         let str =[]
// for (let i = 0; i<x.length; i++){
//     if(x[i] === 'good' ){
//         str.push('good')
//     }
// }
// if (str.length > 2){
//     return 'I smell a series!'
// }else if (str.length){
// return 'Publish!'
// }else if (!str.length){
//   return   'Fail!'
// }
//
//     }

    // 3 function well(x){
    //     let count = 0;
    //     for (let i = 0; i < x.length; i++) {
    //         if (x[i] === 'good') {
    //             count++;
    //             if (count == 3)
    //                 break;
    //         }
    //     }
    //     return ['Fail!', 'Publish!', 'Publish!', 'I smell a series!'][count]
    // }
    //
    //
    // console.log(well(['bad', 'bad', 'bad']));
    // console.log(well(['good', 'bad', 'bad', 'bad', 'good']));
    // console.log(well(['good', 'bad', 'bad', 'bad', 'bad', 'good', 'bad', 'bad', 'good']));
    // console.log(well(['good', 'bad', 'bad', 'good', 'bad', 'good', 'bad', 'bad', 'good']));
    // console.log(well(["bad","bad","bad","bad","bad","good","bad","bad","bad","bad","good","bad"]));
</script>
</body>
</html>
