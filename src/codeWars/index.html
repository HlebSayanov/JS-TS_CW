<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<script>
    // Кто помнит свое время на школьном дворе, когда девочки брали цветок и рвали его лепестки, произнося каждую из следующих фраз каждый раз, когда отрывался лепесток:
    //
    //     "Я тебя люблю"
    // "немного"
    // "много"
    // "страстно"
    // "безумно"
    // "нисколько"
    // Если лепестков больше 6, вы начинаете сначала "I love you"для 7 лепестков, "a little"для 8 лепестков и так далее.
    //
    //     Когда был сорван последний лепесток, раздались крики волнения, мечты, нахлынувшие мысли и эмоции.
    //
    //     Ваша цель в этой ката - определить, какую фразу девушки сказали бы на последнем лепестке цветка с заданным количеством лепестков. Количество лепестков всегда больше 0.

    // function howMuchILoveYou(nbPetals) {
    //        if(nbPetals%6 === 1){
    //            return "I love you"
    //        } if(nbPetals%6 === 2){
    //            return "a little"
    //        } if(nbPetals%6 === 3){
    //            return "a lot"
    //        } if(nbPetals%6 === 4){
    //            return "passionately"
    //        } if(nbPetals%6 === 5){
    //            return "madly"
    //        }if(nbPetals%6 === 6){
    //            return "not at all"
    //        }
    // }
    //
    //             console.log(howMuchILoveYou(1))
    //             console.log(howMuchILoveYou(7))
    //             console.log(howMuchILoveYou(8))
    //             console.log(howMuchILoveYou(9))
    //             console.log(howMuchILoveYou(10))
    //             console.log(howMuchILoveYou(13))
    //             console.log(howMuchILoveYou(14))

    //=============================================================

    // Задача
    // Даны три целых числа a ,b,c, вернуть наибольшее число , полученное после вставки следующих операторов и скобок :+,*,()
    // Другими словами, попробуйте каждую комбинацию a,b,c с [*+()] и верните максимальное полученное значение (подробнее об этом читайте в примечаниях)
    // Пример
    // С числами 1, 2 и 3 вот несколько способов размещения знаков и скобок :
    //
    //     1 * (2 + 3) = 5
    // 1 * 2 * 3 = 6
    // 1 + 2 * 3 = 7
    // (1 + 2) * 3 = 9
    // Таким образом , максимальное значение , которое вы можете получить, равно 9 .

    // function expressionMatter(a, b, c) {
    //    let x = a*(b+c)
    //    let y = a*b*c
    //    let z = a+b*c
    //    let r = (a +b)*c
    //    let e = a +b+c
    //     return Math.max(x,y,z,r,e)
    // }
    //
    // console.log(expressionMatter(2, 1, 2))
    // console.log(expressionMatter(2, 10, 3))
    // console.log(expressionMatter(1, 8, 1))
    //=====================================================================

    //=================================================================================================

    // Задача
    // Учитывая массив целых чисел , Найдите минимальную сумму , которая получается в результате суммирования каждого произведения двух целых чисел .
    //
    //     Примечания
    // Массив/список будет содержать только положительные значения .
    //     Массив/список всегда будет иметь четный размер
    // Ввод >> Примеры вывода
    // minSum({5,4,2,3}) ==> return (22)
    // Объяснение :
    //     Минимальная сумма , полученная при суммировании каждого произведения двух целых чисел ,  5*2 + 3*4 = 22
    // minSum({12,6,10,26,3,24}) ==> return (342)
    // Объяснение :
    //     Минимальная сумма , полученная при суммировании каждого произведения двух целых чисел ,  26*3 + 24*6 + 12*10 = 342
    // minSum({9,2,8,7,5,4,0,6}) ==> return (74)
    // Объяснение :
    //     Минимальная сумма , полученная при суммировании каждого произведения двух целых чисел ,  9*0 + 8*2 +7*4 +6*5 = 74

    // function minSum(arr) {
    //    let x = arr.sort((a,b)=>b-a).slice(0,arr.length/2)
    //    let y = arr.sort((a,b)=>a-b).slice(0,arr.length/2)
    //         let res =0
    //     for (let i = 0; i < x.length; i++){
    //         res += x[i]* y[i]
    //     }
    //     return res
    // }
    //
    // console.log(minSum([5,4,2,3]))
    // console.log(minSum([12,6,10,26,3,24]))
    // console.log(minSum([9,2,8,7,5,4,0,6]))/

    //=====================================================================================================

    // Введение и разминка (настоятельно рекомендуется)
    // Игра со списками/массивами
    // Задача
    // Учитывая массив /список [] целых чисел , Найдите произведение k максимальных чисел.
    //
    //     Примечания
    // Размер массива/списка не менее 3 .
    //
    //     Числа массива/списка будут представлять собой смесь положительных, отрицательных и нулевых значений .
    //
    //     Возможно повторение чисел в массиве/списке .
    //
    //     Ввод >> Примеры вывода
    // maxProduct ({4, 3, 5}, 2) ==>  return (20)
    // Объяснение :
    //     Так как размер (k) равен 2 , то подпоследовательность размера 2 , которая дает произведение максимумов , равна5 * 4 = 20.
    // maxProduct ({8, 10 , 9, 7}, 3) ==>  return (720)
    // Объяснение :
    //     Поскольку размер (k) равен 3 , то подпоследовательность размера 3 , которая дает произведение максимумов , равна 8 * 9 * 10 = 720.
    // maxProduct ({10, 8, 3, 2, 1, 4, 10}, 5) ==> return (9600)
    // Объяснение :
    //     Поскольку размер (k) равен 5 , то подпоследовательность размера 5 , произведение максимумов которой дает . 10 * 10 * 8 * 4 * 3 = 9600
    // maxProduct ({-4, -27, -15, -6, -1}, 2) ==> return (4)
    // Объяснение :
    //     Так как размер (k) равен 2 , то подпоследовательность размера 2 , которая дает произведение максимумов , равна -4 * -1 = 4.
    // maxProduct ({10, 3, -1, -27} , 3)  return (-30)
    // Объяснение :
    //     Поскольку размер (k) равен 3 , то подпоследовательность размера 3 , которая дает произведение максимумов , равна10 * 3 * -1 = -30.

    // function maxProduct(numbers, size){
    //     let sort = numbers.sort((a,b)=> b-a )
    //     return sort.slice(0,size).reduce((a,b)=>a*b)
    // }
    //
    //
    //
    // console.log(maxProduct([4,3,5], 2))
    // console.log(maxProduct([10,8,7,9], 3))

    //=============================================================================================

    // Напишите функцию, которая принимает список строк в качестве аргумента и возвращает отфильтрованный список, содержащий те же элементы, но с удаленными «гусями».
    //
    // Гуси — это любые строки в следующем массиве, который предварительно заполнен в вашем решении:
    //
    //     ["African", "Roman Tufted", "Toulouse", "Pilgrim", "Steinbacher"]
    // Например, если этот массив был передан в качестве аргумента:
    //
    //     ["Mallard", "Hook Bill", "African", "Crested", "Pilgrim", "Toulouse", "Blue Swedish"]
    // Ваша функция вернет следующий массив:
    //
    //     ["Mallard", "Hook Bill", "Crested", "Blue Swedish"]
    // Элементы в возвращаемом массиве должны быть в том же порядке,
    //     что и в исходном массиве, переданном вашей функции, хотя и с удаленными «гусями».
    // Обратите внимание, что все строки будут в том же регистре, что и предоставленные, а некоторые элементы могут повторяться.

    // function gooseFilter (birds) {
    //     var geese = ["African", "Roman Tufted", "Toulouse", "Pilgrim", "Steinbacher"];
    //
    //     return birds.filter((el)=> el !== geese[0] && el !== geese[1] && el !== geese[2] && el !== geese[3] && el !== geese[4])
    //
    // };
    //function gooseFilter (birds) {
    //     var geese = ["African", "Roman Tufted", "Toulouse", "Pilgrim", "Steinbacher"];
    //     return birds.filter(b => !geese.includes(b));
    // };
    // console.log(gooseFilter(["Mallard", "Hook Bill", "African", "Crested", "Pilgrim", "Toulouse", "Blue Swedish"]))

    //===========================================================================================

    // Создайте функцию, которая принимает в качестве аргумента римскую цифру и возвращает ее значение в виде десятичного целого числа. Вам не нужно проверять форму римской цифры.
    //
    //     Современные римские цифры записываются путем выражения каждой десятичной цифры числа, которое нужно закодировать отдельно, начиная с самой левой цифры и пропуская любые 0. Таким образом, 1990 г. отображается как «MCMXC» (1000 = M, 900 = CM, 90 = XC), а 2008 г. отображается как «MMVIII» (2000 = MM, 8 = VIII). Римская цифра 1666 года, "MDCLXVI", использует каждую букву в порядке убывания.
    //
    //     Пример:
    //
    // solution('XXI'); // should return 21
    // Помощь:
    //
    //     Symbol    Value
    // I          1
    // V          5
    // X          10
    // L          50
    // C          100
    // D          500
    // M          1,000
    // Предоставлено rosettacode.org

    // !!!!!!!!!!!!!!function solution (roman) {
    //
    //     let obj ={
    //         I:1,
    //         V:5,
    //         X:10,
    //         L:50,
    //         C:100,
    //         D:500,
    //         M:1000
    //
    //     }
    //
    //     const keys = Object.keys(obj);
    //     let res = 0
    //   for (let i = 0; i<roman.length; i++){
    //       if(roman[i] === 'I'){
    //           res +=1
    //       } else if(roman[i] === 'V'){
    //           res +=5
    //       }else if(roman[i] === 'X'){
    //           res +=10
    //       }else if(roman[i] === 'L'){
    //           res +=50
    //       }else if(roman[i] === 'C'){
    //           res +=100
    //       }else if(roman[i] === 'D'){
    //           res +=500
    //       }else if(roman[i] === 'M'){
    //           res +=1000
    //       }else if (roman.indexOf()[i]===('IV')){
    //           res+4
    //       }
    //   }
    //
    //     return res
    // }
    //
    //
    // console.log(solution('XXX'));
    // console.log(solution('IV'));
    // console.log(solution('I'));
    // console.log(solution('MMVIII'));
    //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    //=========================================================================================

    //
    //     In this little assignment you are given a string of space separated numbers, and have to return the highest and lowest number.
    //
    //         Examples
    //     highAndLow("1 2 3 4 5");  // return "5 1"
    //     highAndLow("1 2 -3 4 5"); // return "5 -3"
    //     highAndLow("1 9 3 4 -5"); // return "9 -5"
    //     Notes
    //     All numbers are valid Int32, no need to validate them.
    //         There will always be at least one number in the input string.
    //         Output string must be two numbers separated by a single space, and highest number is first.

    // function highAndLow(numbers) {
    //     let a = numbers.split(' ').sort((a, b) => b - a)
    //     let res = a[0] + ' ' + a[a.length - 1]
    //
    //     return res
    //
    // }
    //
    //
    // console.log(highAndLow("8 3 -5 42 -1 0 0 -9 4 7 4 -4"))

    //=======================================================================================

    //На каждую хорошую идею ката приходится немало плохих!
    // В этом ката вам нужно проверить предоставленный массив (x) на наличие хороших идей «хорошо» и
    // плохих идей «плохо». Если есть одна или две хорошие идеи, верните «Опубликовать!», если их больше 2,
    //     верните «Чую серию!». Если нет хороших идей, как это часто бывает, верните «Fail!».

    // 1 const well=(x) => x.includes('good') ? 'Publish!' : 'Fail'

    // function well(x) {
    //     let str = []
    //     for (let i = 0; i < x.length; i++) {
    //         if (x[i] === 'good') {
    //             str.push('good')
    //         }
    //     }
    //     if (str.length > 2) {
    //         return 'I smell a series!'
    //     } else if (str.length) {
    //         return 'Publish!'
    //     } else if (!str.length) {
    //         return 'Fail!'
    //     }
    //
    // }


    // 3 function well(x){
    //     let count = 0;
    //     for (let i = 0; i < x.length; i++) {
    //         if (x[i] === 'good') {
    //             count++;
    //             if (count == 3)
    //                 break;
    //         }
    //     }
    //     return ['Fail!', 'Publish!', 'Publish!', 'I smell a series!'][count]
    // }
    //
    //
    // console.log(well(['bad', 'bad', 'bad']));
    // console.log(well(['good', 'bad', 'bad', 'bad', 'good']));
    // console.log(well(['good', 'bad', 'bad', 'bad', 'bad', 'good', 'bad', 'bad', 'good']));
    // console.log(well(['good', 'bad', 'bad', 'good', 'bad', 'good', 'bad', 'bad', 'good']));
    //    // console.log(well(["bad","bad","bad","bad","bad","good","bad","bad","bad","bad","good","bad"]));

    //=============================================================================================

    // В этом простом упражнении вы создадите программу, которая принимает значение ,
    //     integer и возвращает список его кратных до другого значения, limit .
    //     Если limitкратно integer, оно также должно быть включено.
    //     В функцию всегда будут передаваться только положительные целые числа, не состоящие из 0.
    // Предел всегда будет выше основания.
    //
    //     Например, если переданы параметры (2, 6), функция должна возвращать [2, 4, 6]значения 2, 4 и 6, кратные от 2 до 6.

    // function findMultiples(integer, limit) {
    //     let arr = []
    //     for(let i = integer; i<=limit;i+=integer){
    //              arr.push(i)
    //
    //         }
    //     return arr
    // }
    // console.log(findMultiples(5, 25));   //[5, 10, 15, 20, 25]
    // console.log(findMultiples(5, 7));
    //=====================================================================================================

    //==============================================================================================

    // Given a 2D ( nested ) list ( array, vector, .. ) of size m * n, your task is to find the sum of the minimum values in each row.
    //
    //     For Example:
    //
    //     [ [ 1, 2, 3, 4, 5 ]        #  minimum value of row is 1
    //     , [ 5, 6, 7, 8, 9 ]        #  minimum value of row is 5
    //     , [ 20, 21, 34, 56, 100 ]  #  minimum value of row is 20
    // ]
    // So the function should return 26 because the sum of the minimums is 1 + 5 + 20 = 26.
    //
    // Note: You will always be given a non-empty list containing positive values.
    //
    //     ENJOY CODING :)

    // function sumOfMinimums(arr) {
    //    let res = 0
    //     arr.map(el=>{
    //      res += el.sort((a,b)=>a-b).shift()
    //    })
    //     return res
    // }
    //
    // console.log(sumOfMinimums([[7, 9, 8, 6, 2], [6, 3, 5, 4, 3], [5, 8, 7, 4, 5]]));

    //======================================================================================================

    // Ваша задача состоит в том, чтобы создать функцию,
    //     которая может принимать любое неотрицательное
    // целое число в качестве аргумента и возвращать его с цифрами в порядке убывания.
    //     По сути, переставьте цифры, чтобы получить максимально возможное число.
    //
    //     Примеры:
    // Вход: 42145 Выход:54421
    //
    // Вход: 145263 Выход:654321
    //
    // Вход: 123456789 Выход:987654321
    //
    //

    //
    // function descendingOrder(n){
    //
    //     return Number(String(n).split('').sort((a,b)=>b-a).join('') )
    // }
    //
    //
    // console.log(descendingOrder(1021));

    //===================================================================================

    // Вам дадут слово. Ваша задача — вернуть средний символ слова. Если длина слова нечетная,
    //     вернуть средний символ. Если длина слова четная, верните средние 2 символа.
    //
    //     #Примеры:
    //
    // Kata.getMiddle("test") should return "es"
    //
    // Kata.getMiddle("testing") should return "t"
    //
    // Kata.getMiddle("middle") should return "dd"
    //
    // Kata.getMiddle("A") should return "A"
    // #Вход
    //
    // Слово (строка) длины 0 < str < 1000(в javascript вы можете получить чуть больше 1000 в некоторых
    // тестовых примерах из-за ошибки в тестовых примерах). Вам не нужно тестировать для этого. Это только здесь,
    //     чтобы сказать вам, что вам не нужно беспокоиться о тайм-ауте вашего решения.
    //
    //     #Выход
    //
    // Средний символ (символы) слова, представленного в виде строки.
    //

    // function getMiddle(s) {
    //     // let arr = s.split(' ')
    //     if(s.length % 2 === 0){
    //         return s[s.length /2-1] +s[s.length /2]
    //     }else {
    //        return  s[Math.floor(s.length /2)]
    //     }
    //
    // }
    //
    // console.log(getMiddle("test"));
    // console.log(getMiddle("testing"));
    // console.log(getMiddle("middle"));

//==============================================================================================================

    //     В этом ката вы создадите функцию,
//         которая берет список неотрицательных целых чисел и строк
//     и возвращает новый список с отфильтрованными строками.
//
//         Пример
//     filter_list([1,2,'a','b']) == [1,2]
//     filter_list([1,'a','b',0,15]) == [1,0,15]
//     filter_list([1,2,'aasf','1','123',123]) == [1,2,123]

    // function filter_list(l) {
    //    return l.filter(el=> el === Number(el))
    // }
    //
    // console.log(filter_list([1, 2, 'a', 'b']));

//==============================================================================================

    //     Создайте функцию, которая возвращает значение, умноженное на 50 и увеличенное на 6. Если введенное значение
//     является строкой, оно должно возвращать «Ошибка».


//     const problem = (x)=> typeof x === 'number' ? x*50+6:'Error'

    //=====================================================================================================

    // Американцы странные люди: в их домах первый этаж фактически является цокольным, а 13-го этажа нет (из-за суеверия).
    //
    // Напишите функцию, которая по заданному нижнему пределу в американской системе возвращает нижний предел в европейской системе.
    //
    //     Когда 1-й этаж заменяется цокольным этажом, а 13-й этаж удаляется, числа перемещаются вниз, чтобы занять свое место. В случае выше 13 они перемещаются вниз на два, потому что под ними есть два пропущенных числа.
    //
    // Подвалы (негативы) остаются такими же, как и универсальный уровень.
    //
    //     Больше информации здесь
    //
    // Примеры
    // 1  =>  0
    // 0  =>  0
    // 5  =>  4
    // 15  =>  13
    // -3  =>  -3


    // function getRealFloor(n) {
    //     if(n < 1){
    //         return n
    //     }else if(n>13){
    //       return   n-2
    //     }else{
    //         n-1
    //     }
    //
    // }

    //======================================================================================================

    // Проверьте, содержит ли строка одинаковое количество «x» и «o».
    // Метод должен возвращать логическое значение и не учитывать регистр.
    //     Строка может содержать любой символ.
    //
    //     Примеры ввода/вывода:
    //
    // XO("ooxx") => true
    // XO("xooxx") => false
    // XO("ooxXm") => true
    // XO("zpzpzpp") => true // when no 'x' and 'o' is present should return true
    // XO("zzoo") => false
    //

    // const XO =(str)=> {
    //   let arr = str.toLowerCase().split('')
    //     let x = []
    //     let y = []
    //     for (let i = 0; i<arr.length; i ++){
    //         if(arr[i]==='x'){
    //             x.push(arr[i])
    //         }else if(arr[i]==='o'){
    //             y.push(arr[i])
    //         }
    //     }
    //     return x.length === y.length
    // }
    //
    //
    //
    // console.log(XO('xo'));
    // console.log(XO("xxOo"));
    // console.log(XO("xxxm"));
    // console.log(XO("Oo"));
    // console.log(XO("ooom"));

//=================================================================================================================
</script>
</body>
</html>
