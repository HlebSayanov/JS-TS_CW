<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<script>
    // Кто помнит свое время на школьном дворе, когда девочки брали цветок и рвали его лепестки, произнося каждую из следующих фраз каждый раз, когда отрывался лепесток:
    //
    //     "Я тебя люблю"
    // "немного"
    // "много"
    // "страстно"
    // "безумно"
    // "нисколько"
    // Если лепестков больше 6, вы начинаете сначала "I love you"для 7 лепестков, "a little"для 8 лепестков и так далее.
    //
    //     Когда был сорван последний лепесток, раздались крики волнения, мечты, нахлынувшие мысли и эмоции.
    //
    //     Ваша цель в этой ката - определить, какую фразу девушки сказали бы на последнем лепестке цветка с заданным количеством лепестков. Количество лепестков всегда больше 0.

    // function howMuchILoveYou(nbPetals) {
    //        if(nbPetals%6 === 1){
    //            return "I love you"
    //        } if(nbPetals%6 === 2){
    //            return "a little"
    //        } if(nbPetals%6 === 3){
    //            return "a lot"
    //        } if(nbPetals%6 === 4){
    //            return "passionately"
    //        } if(nbPetals%6 === 5){
    //            return "madly"
    //        }if(nbPetals%6 === 6){
    //            return "not at all"
    //        }
    // }
    //
    //             console.log(howMuchILoveYou(1))
    //             console.log(howMuchILoveYou(7))
    //             console.log(howMuchILoveYou(8))
    //             console.log(howMuchILoveYou(9))
    //             console.log(howMuchILoveYou(10))
    //             console.log(howMuchILoveYou(13))
    //             console.log(howMuchILoveYou(14))

    //=============================================================

    // Задача
    // Даны три целых числа a ,b,c, вернуть наибольшее число , полученное после вставки следующих операторов и скобок :+,*,()
    // Другими словами, попробуйте каждую комбинацию a,b,c с [*+()] и верните максимальное полученное значение (подробнее об этом читайте в примечаниях)
    // Пример
    // С числами 1, 2 и 3 вот несколько способов размещения знаков и скобок :
    //
    //     1 * (2 + 3) = 5
    // 1 * 2 * 3 = 6
    // 1 + 2 * 3 = 7
    // (1 + 2) * 3 = 9
    // Таким образом , максимальное значение , которое вы можете получить, равно 9 .

    // function expressionMatter(a, b, c) {
    //    let x = a*(b+c)
    //    let y = a*b*c
    //    let z = a+b*c
    //    let r = (a +b)*c
    //    let e = a +b+c
    //     return Math.max(x,y,z,r,e)
    // }
    //
    // console.log(expressionMatter(2, 1, 2))
    // console.log(expressionMatter(2, 10, 3))
    // console.log(expressionMatter(1, 8, 1))
    //=====================================================================

    //=================================================================================================

    // Задача
    // Учитывая массив целых чисел , Найдите минимальную сумму , которая получается в результате суммирования каждого произведения двух целых чисел .
    //
    //     Примечания
    // Массив/список будет содержать только положительные значения .
    //     Массив/список всегда будет иметь четный размер
    // Ввод >> Примеры вывода
    // minSum({5,4,2,3}) ==> return (22)
    // Объяснение :
    //     Минимальная сумма , полученная при суммировании каждого произведения двух целых чисел ,  5*2 + 3*4 = 22
    // minSum({12,6,10,26,3,24}) ==> return (342)
    // Объяснение :
    //     Минимальная сумма , полученная при суммировании каждого произведения двух целых чисел ,  26*3 + 24*6 + 12*10 = 342
    // minSum({9,2,8,7,5,4,0,6}) ==> return (74)
    // Объяснение :
    //     Минимальная сумма , полученная при суммировании каждого произведения двух целых чисел ,  9*0 + 8*2 +7*4 +6*5 = 74

    // function minSum(arr) {
    //    let x = arr.sort((a,b)=>b-a).slice(0,arr.length/2)
    //    let y = arr.sort((a,b)=>a-b).slice(0,arr.length/2)
    //         let res =0
    //     for (let i = 0; i < x.length; i++){
    //         res += x[i]* y[i]
    //     }
    //     return res
    // }
    //
    // console.log(minSum([5,4,2,3]))
    // console.log(minSum([12,6,10,26,3,24]))
    // console.log(minSum([9,2,8,7,5,4,0,6]))/

    //=====================================================================================================

    // Введение и разминка (настоятельно рекомендуется)
    // Игра со списками/массивами
    // Задача
    // Учитывая массив /список [] целых чисел , Найдите произведение k максимальных чисел.
    //
    //     Примечания
    // Размер массива/списка не менее 3 .
    //
    //     Числа массива/списка будут представлять собой смесь положительных, отрицательных и нулевых значений .
    //
    //     Возможно повторение чисел в массиве/списке .
    //
    //     Ввод >> Примеры вывода
    // maxProduct ({4, 3, 5}, 2) ==>  return (20)
    // Объяснение :
    //     Так как размер (k) равен 2 , то подпоследовательность размера 2 , которая дает произведение максимумов , равна5 * 4 = 20.
    // maxProduct ({8, 10 , 9, 7}, 3) ==>  return (720)
    // Объяснение :
    //     Поскольку размер (k) равен 3 , то подпоследовательность размера 3 , которая дает произведение максимумов , равна 8 * 9 * 10 = 720.
    // maxProduct ({10, 8, 3, 2, 1, 4, 10}, 5) ==> return (9600)
    // Объяснение :
    //     Поскольку размер (k) равен 5 , то подпоследовательность размера 5 , произведение максимумов которой дает . 10 * 10 * 8 * 4 * 3 = 9600
    // maxProduct ({-4, -27, -15, -6, -1}, 2) ==> return (4)
    // Объяснение :
    //     Так как размер (k) равен 2 , то подпоследовательность размера 2 , которая дает произведение максимумов , равна -4 * -1 = 4.
    // maxProduct ({10, 3, -1, -27} , 3)  return (-30)
    // Объяснение :
    //     Поскольку размер (k) равен 3 , то подпоследовательность размера 3 , которая дает произведение максимумов , равна10 * 3 * -1 = -30.

    // function maxProduct(numbers, size){
    //     let sort = numbers.sort((a,b)=> b-a )
    //     return sort.slice(0,size).reduce((a,b)=>a*b)
    // }
    //
    //
    //
    // console.log(maxProduct([4,3,5], 2))
    // console.log(maxProduct([10,8,7,9], 3))

    //=============================================================================================

    // Напишите функцию, которая принимает список строк в качестве аргумента и возвращает отфильтрованный список, содержащий те же элементы, но с удаленными «гусями».
    //
    // Гуси — это любые строки в следующем массиве, который предварительно заполнен в вашем решении:
    //
    //     ["African", "Roman Tufted", "Toulouse", "Pilgrim", "Steinbacher"]
    // Например, если этот массив был передан в качестве аргумента:
    //
    //     ["Mallard", "Hook Bill", "African", "Crested", "Pilgrim", "Toulouse", "Blue Swedish"]
    // Ваша функция вернет следующий массив:
    //
    //     ["Mallard", "Hook Bill", "Crested", "Blue Swedish"]
    // Элементы в возвращаемом массиве должны быть в том же порядке,
    //     что и в исходном массиве, переданном вашей функции, хотя и с удаленными «гусями».
    // Обратите внимание, что все строки будут в том же регистре, что и предоставленные, а некоторые элементы могут повторяться.

    // function gooseFilter (birds) {
    //     var geese = ["African", "Roman Tufted", "Toulouse", "Pilgrim", "Steinbacher"];
    //
    //     return birds.filter((el)=> el !== geese[0] && el !== geese[1] && el !== geese[2] && el !== geese[3] && el !== geese[4])
    //
    // };
    //function gooseFilter (birds) {
    //     var geese = ["African", "Roman Tufted", "Toulouse", "Pilgrim", "Steinbacher"];
    //     return birds.filter(b => !geese.includes(b));
    // };
    // console.log(gooseFilter(["Mallard", "Hook Bill", "African", "Crested", "Pilgrim", "Toulouse", "Blue Swedish"]))

    //===========================================================================================

    // Создайте функцию, которая принимает в качестве аргумента римскую цифру и возвращает ее значение в виде десятичного целого числа. Вам не нужно проверять форму римской цифры.
    //
    //     Современные римские цифры записываются путем выражения каждой десятичной цифры числа, которое нужно закодировать отдельно, начиная с самой левой цифры и пропуская любые 0. Таким образом, 1990 г. отображается как «MCMXC» (1000 = M, 900 = CM, 90 = XC), а 2008 г. отображается как «MMVIII» (2000 = MM, 8 = VIII). Римская цифра 1666 года, "MDCLXVI", использует каждую букву в порядке убывания.
    //
    //     Пример:
    //
    // solution('XXI'); // should return 21
    // Помощь:
    //
    //     Symbol    Value
    // I          1
    // V          5
    // X          10
    // L          50
    // C          100
    // D          500
    // M          1,000
    // Предоставлено rosettacode.org

    // !!!!!!!!!!!!!!function solution (roman) {
    //
    //     let obj ={
    //         I:1,
    //         V:5,
    //         X:10,
    //         L:50,
    //         C:100,
    //         D:500,
    //         M:1000
    //
    //     }
    //
    //     const keys = Object.keys(obj);
    //     let res = 0
    //   for (let i = 0; i<roman.length; i++){
    //       if(roman[i] === 'I'){
    //           res +=1
    //       } else if(roman[i] === 'V'){
    //           res +=5
    //       }else if(roman[i] === 'X'){
    //           res +=10
    //       }else if(roman[i] === 'L'){
    //           res +=50
    //       }else if(roman[i] === 'C'){
    //           res +=100
    //       }else if(roman[i] === 'D'){
    //           res +=500
    //       }else if(roman[i] === 'M'){
    //           res +=1000
    //       }else if (roman.indexOf()[i]===('IV')){
    //           res+4
    //       }
    //   }
    //
    //     return res
    // }
    //
    //
    // console.log(solution('XXX'));
    // console.log(solution('IV'));
    // console.log(solution('I'));
    // console.log(solution('MMVIII'));
    //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    //=========================================================================================

    //
    //     In this little assignment you are given a string of space separated numbers, and have to return the highest and lowest number.
    //
    //         Examples
    //     highAndLow("1 2 3 4 5");  // return "5 1"
    //     highAndLow("1 2 -3 4 5"); // return "5 -3"
    //     highAndLow("1 9 3 4 -5"); // return "9 -5"
    //     Notes
    //     All numbers are valid Int32, no need to validate them.
    //         There will always be at least one number in the input string.
    //         Output string must be two numbers separated by a single space, and highest number is first.

    // function highAndLow(numbers) {
    //     let a = numbers.split(' ').sort((a, b) => b - a)
    //     let res = a[0] + ' ' + a[a.length - 1]
    //
    //     return res
    //
    // }
    //
    //
    // console.log(highAndLow("8 3 -5 42 -1 0 0 -9 4 7 4 -4"))

    //=======================================================================================

    //На каждую хорошую идею ката приходится немало плохих!
    // В этом ката вам нужно проверить предоставленный массив (x) на наличие хороших идей «хорошо» и
    // плохих идей «плохо». Если есть одна или две хорошие идеи, верните «Опубликовать!», если их больше 2,
    //     верните «Чую серию!». Если нет хороших идей, как это часто бывает, верните «Fail!».

    // 1 const well=(x) => x.includes('good') ? 'Publish!' : 'Fail'

    // function well(x) {
    //     let str = []
    //     for (let i = 0; i < x.length; i++) {
    //         if (x[i] === 'good') {
    //             str.push('good')
    //         }
    //     }
    //     if (str.length > 2) {
    //         return 'I smell a series!'
    //     } else if (str.length) {
    //         return 'Publish!'
    //     } else if (!str.length) {
    //         return 'Fail!'
    //     }
    //
    // }


    // 3 function well(x){
    //     let count = 0;
    //     for (let i = 0; i < x.length; i++) {
    //         if (x[i] === 'good') {
    //             count++;
    //             if (count == 3)
    //                 break;
    //         }
    //     }
    //     return ['Fail!', 'Publish!', 'Publish!', 'I smell a series!'][count]
    // }
    //
    //
    // console.log(well(['bad', 'bad', 'bad']));
    // console.log(well(['good', 'bad', 'bad', 'bad', 'good']));
    // console.log(well(['good', 'bad', 'bad', 'bad', 'bad', 'good', 'bad', 'bad', 'good']));
    // console.log(well(['good', 'bad', 'bad', 'good', 'bad', 'good', 'bad', 'bad', 'good']));
    //    // console.log(well(["bad","bad","bad","bad","bad","good","bad","bad","bad","bad","good","bad"]));

    //=============================================================================================

    // В этом простом упражнении вы создадите программу, которая принимает значение ,
    //     integer и возвращает список его кратных до другого значения, limit .
    //     Если limitкратно integer, оно также должно быть включено.
    //     В функцию всегда будут передаваться только положительные целые числа, не состоящие из 0.
    // Предел всегда будет выше основания.
    //
    //     Например, если переданы параметры (2, 6), функция должна возвращать [2, 4, 6]значения 2, 4 и 6, кратные от 2 до 6.

    // function findMultiples(integer, limit) {
    //     let arr = []
    //     for(let i = integer; i<=limit;i+=integer){
    //              arr.push(i)
    //
    //         }
    //     return arr
    // }
    // console.log(findMultiples(5, 25));   //[5, 10, 15, 20, 25]
    // console.log(findMultiples(5, 7));
    //=====================================================================================================

    //==============================================================================================

    // Given a 2D ( nested ) list ( array, vector, .. ) of size m * n, your task is to find the sum of the minimum values in each row.
    //
    //     For Example:
    //
    //     [ [ 1, 2, 3, 4, 5 ]        #  minimum value of row is 1
    //     , [ 5, 6, 7, 8, 9 ]        #  minimum value of row is 5
    //     , [ 20, 21, 34, 56, 100 ]  #  minimum value of row is 20
    // ]
    // So the function should return 26 because the sum of the minimums is 1 + 5 + 20 = 26.
    //
    // Note: You will always be given a non-empty list containing positive values.
    //
    //     ENJOY CODING :)

    // function sumOfMinimums(arr) {
    //    let res = 0
    //     arr.map(el=>{
    //      res += el.sort((a,b)=>a-b).shift()
    //    })
    //     return res
    // }
    //
    // console.log(sumOfMinimums([[7, 9, 8, 6, 2], [6, 3, 5, 4, 3], [5, 8, 7, 4, 5]]));

    //======================================================================================================

    // Ваша задача состоит в том, чтобы создать функцию,
    //     которая может принимать любое неотрицательное
    // целое число в качестве аргумента и возвращать его с цифрами в порядке убывания.
    //     По сути, переставьте цифры, чтобы получить максимально возможное число.
    //
    //     Примеры:
    // Вход: 42145 Выход:54421
    //
    // Вход: 145263 Выход:654321
    //
    // Вход: 123456789 Выход:987654321
    //
    //

    //
    // function descendingOrder(n){
    //
    //     return Number(String(n).split('').sort((a,b)=>b-a).join('') )
    // }
    //
    //
    // console.log(descendingOrder(1021));

    //===================================================================================

    // Вам дадут слово. Ваша задача — вернуть средний символ слова. Если длина слова нечетная,
    //     вернуть средний символ. Если длина слова четная, верните средние 2 символа.
    //
    //     #Примеры:
    //
    // Kata.getMiddle("test") should return "es"
    //
    // Kata.getMiddle("testing") should return "t"
    //
    // Kata.getMiddle("middle") should return "dd"
    //
    // Kata.getMiddle("A") should return "A"
    // #Вход
    //
    // Слово (строка) длины 0 < str < 1000(в javascript вы можете получить чуть больше 1000 в некоторых
    // тестовых примерах из-за ошибки в тестовых примерах). Вам не нужно тестировать для этого. Это только здесь,
    //     чтобы сказать вам, что вам не нужно беспокоиться о тайм-ауте вашего решения.
    //
    //     #Выход
    //
    // Средний символ (символы) слова, представленного в виде строки.
    //

    // function getMiddle(s) {
    //     // let arr = s.split(' ')
    //     if(s.length % 2 === 0){
    //         return s[s.length /2-1] +s[s.length /2]
    //     }else {
    //        return  s[Math.floor(s.length /2)]
    //     }
    //
    // }
    //
    // console.log(getMiddle("test"));
    // console.log(getMiddle("testing"));
    // console.log(getMiddle("middle"));

//==============================================================================================================

    //     В этом ката вы создадите функцию,
//         которая берет список неотрицательных целых чисел и строк
//     и возвращает новый список с отфильтрованными строками.
//
//         Пример
//     filter_list([1,2,'a','b']) == [1,2]
//     filter_list([1,'a','b',0,15]) == [1,0,15]
//     filter_list([1,2,'aasf','1','123',123]) == [1,2,123]

    // function filter_list(l) {
    //    return l.filter(el=> el === Number(el))
    // }
    //
    // console.log(filter_list([1, 2, 'a', 'b']));

//==============================================================================================

    //     Создайте функцию, которая возвращает значение, умноженное на 50 и увеличенное на 6. Если введенное значение
//     является строкой, оно должно возвращать «Ошибка».


//     const problem = (x)=> typeof x === 'number' ? x*50+6:'Error'

    //=====================================================================================================

    // Американцы странные люди: в их домах первый этаж фактически является цокольным, а 13-го этажа нет (из-за суеверия).
    //
    // Напишите функцию, которая по заданному нижнему пределу в американской системе возвращает нижний предел в европейской системе.
    //
    //     Когда 1-й этаж заменяется цокольным этажом, а 13-й этаж удаляется, числа перемещаются вниз, чтобы занять свое место. В случае выше 13 они перемещаются вниз на два, потому что под ними есть два пропущенных числа.
    //
    // Подвалы (негативы) остаются такими же, как и универсальный уровень.
    //
    //     Больше информации здесь
    //
    // Примеры
    // 1  =>  0
    // 0  =>  0
    // 5  =>  4
    // 15  =>  13
    // -3  =>  -3


    // function getRealFloor(n) {
    //     if(n < 1){
    //         return n
    //     }else if(n>13){
    //       return   n-2
    //     }else{
    //         n-1
    //     }
    //
    // }

    //======================================================================================================

    // Проверьте, содержит ли строка одинаковое количество «x» и «o».
    // Метод должен возвращать логическое значение и не учитывать регистр.
    //     Строка может содержать любой символ.
    //
    //     Примеры ввода/вывода:
    //
    // XO("ooxx") => true
    // XO("xooxx") => false
    // XO("ooxXm") => true
    // XO("zpzpzpp") => true // when no 'x' and 'o' is present should return true
    // XO("zzoo") => false
    //

    // const XO =(str)=> {
    //   let arr = str.toLowerCase().split('')
    //     let x = []
    //     let y = []
    //     for (let i = 0; i<arr.length; i ++){
    //         if(arr[i]==='x'){
    //             x.push(arr[i])
    //         }else if(arr[i]==='o'){
    //             y.push(arr[i])
    //         }
    //     }
    //     return x.length === y.length
    // }
    //
    //
    //
    // console.log(XO('xo'));
    // console.log(XO("xxOo"));
    // console.log(XO("xxxm"));
    // console.log(XO("Oo"));
    // console.log(XO("ooom"));

//=================================================================================================================

    // Write a function that returns a string in which firstname is swapped with last name
    // Example(Input --> Output)

    // "john McClane" --> "McClane john"

    // const nameShuffler=(str)=> str.split(' ').reverse().join(' ')
    // console.log(nameShuffler('john McClane'));

    //==========================================================================================================
    // Дан массив чисел. В цикле while обойдите массив и значения всех элементов
    // с нечетным индексом умножьте на 2.
    // Значения элементов с четным индексом должны остаться без изменения.
    //
    //     let arr = [1,2,3,4,5]
    //     let index =0
    //     while (index <arr.length){
    //       if(index%2==1){
    //           arr[index] *=2;
    //       }
    //
    //         index++
    //     }
    // console.log(arr)

//============================================================================================================


    // Тролли атакуют ваш раздел комментариев!
    //     Обычный способ справиться с этой ситуацией — удалить все гласные из комментариев троллей, нейтрализуя угрозу.
    //     Ваша задача — написать функцию, которая принимает строку и возвращает новую строку, в которой удалены все гласные.
    //     Например, строка «Этот сайт для неудачников, LOL!» станет «Ths wbst s fr lsrs LL!».
    // Примечание: для этой ката yне считается гласной.


    // function disemvowel(str) {
    //     let  arr = ['a','A','o','O','e','E','i','I', 'u','U']
    //
    //     return str.split('').filter(el => el !== arr[0] && el !== arr[1] && el !== arr[2] && el !== arr[3]
    //         && el !== arr[4] && el !== arr[5] && el !== arr[6] && el !== arr[7] && el !== arr[8] && el !== arr[9]
    //     ).join('')
    //
    //
    // }
    // console.log(disemvowel("This website is for losers LOL!"));

    //======================================================================================================

    // Просто, учитывая строку слов, вернуть длину кратчайшего слова (слов).
    //     Строка никогда не будет пустой, и вам не нужно учитывать разные типы данных.

   //  function findShort(s){
   // let arr =  s.split(' ')
   //      let x = []
   //      for(let i =0; i<arr.length;i++){
   //          x.push(arr[i].length)
   //      }
   //      return x.sort((a,b)=>a-b)[0]
   //  }
   //
   //  console.log(findShort("bitcoin take over the world maybe who knows perhaps"));

    //=================================================================================================
    //
    // Выборка чисел из массива по условию
    // Обойдите циклом массив чисел numbers и
    // сохраните в новый массив evenNumbers первые три четных числа из оригинального массива.
    //     Предусмотрите выход из цикла, когда в массиве evenNumbers уже есть три значения.

    // const numbers = [1, 2, 2, 13, 11, 7, 18, 20, 22, 14, 15];
    // const evenNumbers = []
    // for(let i=0; i<numbers.length; i+=2){
    //     evenNumbers.push(numbers[i])
    //     if (evenNumbers.length ===3 ) break
    // }

//======================================================================================================

    // Банкоматы позволяют использовать 4- или 6-значные PIN-коды,
    //     а PIN-коды не могут содержать ничего, кроме ровно 4 или ровно 6 цифр.
    //     Если функции передана допустимая строка PIN-кода, верните true, иначе верните false.
    //
    // Примеры ( Ввод --> Вывод)
    // "1234"   -->  true
    // "12345"  -->  false
    // "a234"   -->  false

    // function validatePIN(pin) {
    //     const preparedPin = pin.replace(/\D/g, '');
    //
    //     return preparedPin === pin && (pin.length === 4 || pin.length === 6);
    // }
    //     // pin.length === 4 || pin.length ===6 ? true :false
    //
    //
    //
    // console.log(validatePIN("a234"));
    // console.log(validatePIN("-1.234"));
    // console.log(validatePIN("1234567"));
    // console.log(validatePIN("1234"));
    // console.log(validatePIN("123456"));

    //
    // Создайте программу, которая фильтрует список строк и возвращает список, содержащий только имена ваших друзей.
    //
    //     Если в имени ровно 4 буквы, можете быть уверены, что оно должно быть вашим другом! В противном случае, вы можете быть уверены, что он не...
    //
    // Пример: ввод = ["Райан", "Киран", "Джейсон", "Юс"], вывод = ["Райан", "Юс"]
    //
    // то есть
    //
    // friend ["Ryan", "Kieran", "Mark"] `shouldBe` ["Ryan", "Mark"]
    // Примечание: сохраните исходный порядок имен в выводе.

    // function friend(friends){
    //    const arr = []
    //     for(let i =0; i<friends.length;i++){
    //         friends[i].length === 4 && arr.push(friends[i])
    //     }
    //    return arr
    // }
    //
    //
    // console.log(friend(["Ryan", "Kieran", "Mark"]));

    //==============================================================================================

    // Крокетный клуб Western Suburbs имеет две категории членства: Senior и Open. Им нужна ваша помощь с формой заявки, в которой потенциальным членам будет указано, в какую категорию они будут помещены.
    //
    //     Чтобы быть пожилым, член должен быть не моложе 55 лет и иметь гандикап больше 7. В этом крокетном клубе гандикап варьируется от -2 до +26; чем лучше игрок, тем ниже гандикап.
    //
    //     Вход
    // Ввод будет состоять из списка пар. Каждая пара содержит информацию об одном потенциальном члене. Информация состоит из целого числа для возраста человека и целого числа для инвалидности человека.
    //
    //     Выход
    // Вывод будет состоять из списка строковых значений (в Haskell и C: Openили Senior), указывающих, должен ли соответствующий элемент быть помещен в старшую или открытую категорию.
    //
    //     Пример
    // input =  [[18, 20], [45, 2], [61, 12], [37, 6], [21, 21], [78, 9]]
    // output = ["Open", "Open", "Senior", "Open", "Open", "Senior"]

    // function openOrSenior(data){
    //    return data.map(el=> el[0] >= 55 && el[1] > 7 ? 'Senior' : 'Open')
    // }
    //
    // console.log(openOrSenior([[45, 12], [55, 21], [19, -2], [104, 20]]));

    //==========================================================================================

    // const shortestWord = (str) => {
    //        return  str.split(' ').sort((a,b)=>a.length -b.length)[0]
    // }
    //
    //
    // console.log(shortestWord('Lorem ipsum dolor sit amet.')); // sit
    // console.log(shortestWord('consectetur adipisicing elit. rem')); // rem


    // Пожалуйста, напишите функцию, которая суммирует список, но игнорирует любые повторяющиеся элементы в списке.
    //     Например, для списка [3, 4, 3, 6] функция должна вернуть 10.

    // function sumNoDuplicates(numList) {
    //    return numList.filter(function(item, pos) {
    //         return numList.indexOf(item) == pos;
    //     })
    // }
    // console.log(sumNoDuplicates([1, 1, 2, 3]))
    // console.log(sumNoDuplicates([1, 1, 2, 2, 3]))

    //======================================================================================================

    // Завершите функцию, которая принимает строковый параметр и переворачивает
    // каждое слово в строке. Все пробелы в строке должны быть сохранены.
    //
    //     Примеры
    // "This is an example!" ==> "sihT si na !elpmaxe"
    // "double  spaces"      ==> "elbuod  secaps"
    //
    //
    // function reverseWords(str) {
    //
    //     return str.split('').reverse().join('').split(' ').reverse().join(' ')
    // }

    // console.log(reverseWords('double  spaced  words'));

    // const basicOp=(operation, value1, value2)=> {
    // return eval(value1+operation+value2)
    // }
    //
    //
    //
    // console.log(basicOp('+', 4, 786));

//     const sorting = (a,b) => {
//      if(a>b)  return 1
//      if(a<b)  return -1
//        return 0
//     }
//
//     const food = ["Apple", "Melon", "Banana", "Yogurt", "Orange", "Stawberry"];
//     food.sort(sorting)
//     console.log(food)
//
//     const players = [
//         {
//             id: 1,
//             name: 'Cristiano',
//             surname: 'Ronaldo',
//             club: 'Juventus',
//         },
//         {
//             id: 2,
//             name: 'Lionel',
//             surname: 'Messi',
//             club: 'Barcelona',
//         },
//         {
//             id: 3,
//             name: 'Karim',
//             surname: 'Benzema',
//             club: 'Real Madrid',
//         },
//         {
//             id: 4,
//             name: 'Maxi',
//             surname: 'Gomez',
//             club: 'Valencia',
//         },
//         {
//             id: 5,
//             name: 'Quincy',
//             surname: 'Promes',
//             club: 'Spartak',
//         },
//     ];
// players.sort((a,b)=>sorting(a.surname,b.surname))
//     console.log(players)


//=================================================================================================================

    //Практика по деструктуризации объекта
    // Дан объект link. Используя деструктуризацию объекта, создайте
    // новые переменные со значениями 'blank', 'link', 'anchor', 'Click me'.
    // Имена переменных используйте согласно ключам (где необходимо, используйте переименование, создав переменную с именем renamed).

        /*  const link = {
        href: '#',
        title: 'simple link',
        target: 'blank',
        className: 'link',
        id: null,
        children: {
            span: {
                content: 'Click me',
                className: 'anchor',
            },
        },
    }

    const {
        target,
        className,
        children:{span:{
            content,
            className:renamed
        }}

    } = link

    console.log(target,className,content,renamed)

    */
    /*
    const players = [

        {
            id: 1,
            name: 'Andres',
            surname: 'Iniesta',
            club: 'Vissel Cobe',
        },
        {
            id: 2,
            name: 'Eden',
            surname: 'Hazard',
            club: 'Real Madrid',
        },
        {
            id: 3,
            name: 'Mo',
            surname: 'Salah',
            club: 'Liverpool',
        },
        {
            id: 4,
            name: 'Lionel',
            surname: 'Messi',
            club: 'Barcelona',
        },
    ];

    const jsonPlayers = JSON.stringify(players)
    console.log(jsonPlayers)
*/

        /*  Первый входной массив — это ключ к правильным ответам на экзамене, например ["а", "а", "б", "г"].
        Второй содержит представленные ответы студент
        Два массива не пусты и имеют одинаковую длину. Возвращает оценку для этого массива ответов,
        давая +4 за каждый правильный ответ, -1 за каждый неправильный ответ и +0 за каждый пустой ответ,
        представленный в виде пустой строки (в C используется символ пробела).
    Если оценка < 0, вернуть 0.

    Например:

        checkExam(["a", "a", "b", "b"], ["a", "c", "b", "d"]) → 6
    checkExam(["a", "a", "c", "b"], ["a", "a", "b",  ""]) → 7
    checkExam(["a", "a", "b", "c"], ["a", "a", "b", "c"]) → 16
    checkExam(["b", "c", "b", "a"], ["",  "a", "a", "c"]) → 0
*/

    // function checkExam(array1, array2) {
    //    let sum = 0
    //     for(let i = 0; i<array1.length; i++){
    //         if(array1[i]===array2[i]){
    //              sum+=4
    //         } else {
    //             sum +=-1
    //         } if(array2[i]===""){
    //             sum+=1
    //         }
    //     }
    //     return sum < 0 ? 0 : sum
    // }
    //
    // console.log(checkExam(["a", "a", "b", "b"], ["a", "c", "b", "d"])); // 6
    // console.log((checkExam(["a", "a", "c", "b"], ["a", "a", "b", ""])));
    // console.log((checkExam(["a", "a", "b", "c"], ["a", "a", "b", "c"])));


    // Count the number of divisors of a positive integer n.
    //
    //     Random tests go up to n = 500000.
    //
    // Examples (input --> output)
    // 4 --> 3 (1, 2, 4)
    // 5 --> 2 (1, 5)
    // 12 --> 6 (1, 2, 3, 4, 6, 12)
    // 30 --> 8 (1, 2, 3, 5, 6, 10, 15, 30)
    // Note you should only return a number, the count of divisors.
    //     The numbers between parentheses are shown only for you to see which numbers are counted in each case.

    // function getDivisorsCnt(n){
    //    let x = []
    //     for(let i = 0; i<n; i++){
    //        let a = n % i
    //         if(a==0){
    //             x.push(i)
    //         }
    //     }
    //     return x
    // }
    //
    //
    // console.log(getDivisorsCnt(10));

    // Проблема
    // Похоже, какой-то хулиган-сантехник со своим братом снова бегают и портят ваши сцены.
    //
    //     Соединение pipesэтапов вашего уровня вместе должно быть исправлено, прежде чем вы получите больше жалоб.
    //
    //     Список каналов правильный, когда каждый pipeпосле первого индекса больше (+1), чем предыдущий, и нет дубликатов.
    //
    //     Задача
    // Учитывая список a numbers, верните фиксированный список, чтобы значения увеличивались на 1 для каждого индекса от минимального значения до максимального значения (включая оба).
    //
    // Пример
    // Input:  1,3,5,6,7,8 Output: 1,2,3,4,5,6,7,8

        // function pipeFix(numbers){
        //         const arr = []
        //     for(let i = numbers[0]; i<=numbers[numbers.length-1];i++){
        //         arr.push(i)
        //     }
        //     return arr
        // }
        //
        // console.log(pipeFix([6, 9]));
        // console.log(pipeFix([-1, 4]));

//=========================================================================================================
//
//     Task:
//         Given a list of integers, determine whether the sum of its elements is odd or even.
//
//         Give your answer as a string matching "odd" or "even".
//
//         If the input array is empty consider it as: [0] (array with a zero).
//
//     Examples:
//         Input: [0]
//     Output: "even"
//
//     Input: [0, 1, 4]
//     Output: "odd"
//
//     Input: [0, -1, -5]
//     Output: "even"
//


    // function oddOrEven(array) {
    //     let sum = array.reduce((acc,summ)=> acc+summ,0 )
    //
    //     return Math.abs(sum) %2 ===1   ?  'odd' : 'even'
    // }
    //
    // console.log(oddOrEven([0, 1, 2]));
    // console.log(oddOrEven([1023, -1, 2]));
    //  console.log(oddOrEven([]));
    // console.log(oddOrEven([-1022]));
    // console.log(oddOrEven([-1021]));



    // Напишите функцию, которая принимает массив строк в качестве аргумента и возвращает
    // отсортированный массив, содержащий те же строки,
    // упорядоченные от самой короткой до самой длинной.
    //     Например, если этот массив был передан в качестве аргумента:
    //     ["Telescopes", "Glasses", "Eyes", "Monocles"]
    // Ваша функция вернет следующий массив:
    //     ["Eyes", "Glasses", "Monocles", "Telescopes"]
    // Все строки в массиве, переданном вашей функции, будут иметь разную длину, поэтому вам не придется решать,
    // как упорядочить несколько строк одинаковой длины.

    // function sortByLength (array) {
    //    const arr = array.sort((a,b)=>a.length - b.length)
    //     return arr
    // };
    //
    // console.log(sortByLength(["Beg", "Life", "I", "To"]));

    //==============================================================================================================

    // Вам даны два отсортированных массива, оба из которых содержат только целые числа.
    //     Ваша задача — найти способ объединить их в один, отсортированный по возрастанию.
    //     Завершите функцию mergeArrays(arr1, arr2), где arr1 и arr2 — исходные отсортированные массивы.
    //
    //     Вам не нужно беспокоиться о проверке, так как arr1 и arr2 должны быть массивами с 0 или более целыми числами.
    //     Если и arr1, и arr2 пусты, просто верните пустой массив.
    //
    //     Примечание: arr1 и arr2 могут быть отсортированы в разном порядке.
    //     Также arr1 и arr2 могут иметь одинаковые целые числа. Удалить дубликаты в возвращаемом результате.
    //
    // Примеры (ввод -> вывод)
    // * [1, 2, 3, 4, 5], [6, 7, 8, 9, 10] -> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    //
    // * [1, 3, 5, 7, 9], [10, 8, 6, 4, 2] -> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    //
    // * [1, 3, 5, 7, 9, 11, 12], [1, 2, 3, 4, 5, 10, 12] -> [1, 2, 3, 4, 5, 7, 9, 10, 1

    // function mergeArrays(arr1, arr2) {
    //     let x =arr1.concat(arr2)
    //
    //     return x.filter((el,i)=>x.indexOf(el) == i).sort((a,b)=>a-b)
    // }
    //
    // console.log(mergeArrays([1, 3, 5, 7, 9], [10, 8, 6, 4, 2]));
    // console.log(mergeArrays([1, 3, 5, 7, 9, 11, 12], [1, 2, 3, 4, 5, 10, 12]));


    async function getUsers(){
        try {
            const response = await fetch('https://jsonplaceholder.typicode.com/todos/1')
            const data = await response.json()
            console.log(data);
            throw new Error('WARNOBG')
        }catch (error){
                console.error(error.message)
        }

    }
    // getUsers()
    // console.log(1)
    // console.log(2)
    // console.log(3)


    async function getUsers1(){
        //
        // return Promise.resolve([{id:1, title:'asdas', isDone:false}])
        return Promise.reject('asdasdasd')

    }

getUsers1().catch(console.error)
</script>
</body>
</html>
